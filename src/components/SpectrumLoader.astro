---
export interface Props {
  type?: 'spectrum' | 'custom';
  duration?: number;
  autoHide?: boolean;
}

const { 
  type = 'spectrum',
  duration = 2000,
  autoHide = true
} = Astro.props;
---

<!-- Capa de animación del Spectrum visible desde el principio -->
<div class="spectrum-loader" data-type={type} data-duration={duration} data-auto-hide={autoHide}>
  <div class="spectrum-border-full"></div>
  <div class="spectrum-viewport-mask"></div>
</div>

<style>
  /* Capa de animación visible desde el principio */
  .spectrum-loader {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1000;
    pointer-events: none;
  }

  /* Franjas del Spectrum visibles desde el principio */
  .spectrum-border-full {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      to bottom,
      #ff0000 0%,
      #ff0000 calc(var(--u) * 0.02),
      #00ffff calc(var(--u) * 0.02),
      #00ffff calc(var(--u) * 0.04)
    );
    background-size: calc(var(--u) * 0.08) calc(var(--u) * 0.08);
    animation: stripeMoveFull 0.8s linear infinite;
    z-index: 10;
  }

  /* Máscara del viewport visible desde el principio */
  .spectrum-viewport-mask {
    position: absolute;
    top: calc(var(--u) * 0.08);
    left: calc(var(--u) * 0.08);
    right: calc(var(--u) * 0.08);
    bottom: calc(var(--u) * 0.08);
    background: #c0c0c0;
    z-index: 20;
  }

  @keyframes stripeMoveFull {
    0% {
      background-position: 0 0;
    }
    25% {
      background-position: 0 calc(var(--u) * 0.08);
    }
    50% {
      background-position: 0 0;
    }
    75% {
      background-position: 0 calc(var(--u) * -0.08);
    }
    100% {
      background-position: 0 0;
    }
  }
</style>

<script>
  class SpectrumLoader {
    private container: HTMLElement;
    private duration: number;
    private autoHide: boolean;
    private audioContext: AudioContext | null = null;
    private loadingSound: AudioBufferSourceNode | null = null;

    constructor() {
      this.container = document.querySelector('.spectrum-loader') as HTMLElement;
      if (!this.container) return;

      this.duration = parseInt(this.container.dataset.duration || '2000');
      this.autoHide = this.container.dataset.autoHide === 'true';
      
      this.initAudio();
      this.init();
    }

    private initAudio() {
      try {
        this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
        this.playLoadingSound();
      } catch (error) {
        console.log('Audio no disponible');
      }
    }

    private playLoadingSound() {
      if (!this.audioContext) return;

      // Crear un sonido de carga continuo (por ahora un tono simple)
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      // Frecuencia y volumen para sonido de carga
      oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
      
      // Sonido continuo durante toda la animación
      oscillator.start();
      this.loadingSound = oscillator;
      
      // Parar el sonido cuando termine la animación
      setTimeout(() => {
        if (this.loadingSound) {
          this.loadingSound.stop();
        }
      }, this.duration);
    }

    private init() {
      // La animación ya está visible desde el principio
      // Solo configurar la ocultación automática
      if (this.autoHide) {
        setTimeout(() => {
          this.hide();
        }, this.duration);
      }
    }

    private hide() {
      // Ocultar la capa de animación con fade-out
      this.container.style.opacity = '0';
      this.container.style.transition = 'opacity 0.3s ease-in-out';
      
      // Remover completamente después del fade-out
      setTimeout(() => {
        this.container.remove();
      }, 300);
    }

    // Método público para ocultar manualmente
    public hideManual() {
      this.hide();
    }
  }

  // Inicializar cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', () => {
    new SpectrumLoader();
  });
</script>
