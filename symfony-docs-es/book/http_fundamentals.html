

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Symfony2 y fundamentos HTTP &mdash; symfony-docs-es v1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="symfony-docs-es v1 documentation" href="../index.html" />
    <link rel="up" title="Libro" href="index.html" />
    <link rel="next" title="Symfony2 frente a PHP simple" href="from_flat_php_to_symfony2.html" />
    <link rel="prev" title="Libro" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="from_flat_php_to_symfony2.html" title="Symfony2 frente a PHP simple"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Libro"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">symfony-docs-es v1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Libro</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="symfony2-y-fundamentos-http">
<span id="index-0"></span><h1>Symfony2 y fundamentos HTTP<a class="headerlink" href="#symfony2-y-fundamentos-http" title="Permalink to this headline">¶</a></h1>
<p>¡Enhorabuena! Al aprender acerca de Symfony2, vas bien en tu camino para llegar a ser un más <em>productivo</em>, bien <em>enfocado</em> y <em>popular</em> desarrollador web (en realidad, en la última parte, estás por tu cuenta). Symfony2 está diseñado para volver a lo básico: las herramientas de desarrollo que te permiten desarrollar más rápido y construir aplicaciones más robustas, mientras que permanece fuera de tu camino. Symfony está basado en las mejores ideas de muchas tecnologías: las herramientas y conceptos que estás a punto de aprender representan el esfuerzo de miles de personas, durante muchos años. En otras palabras, no estás aprendiendo &#8220;Symfony&#8221;, estás aprendiendo los fundamentos de la web, buenas prácticas de desarrollo, y cómo utilizar muchas nuevas y asombrosas bibliotecas PHP, dentro o independientemente de Symfony2. Por lo tanto, ¡prepárate!</p>
<p>Fiel a la filosofía Symfony2, este capítulo comienza explicando el concepto fundamental común para el desarrollo web: HTTP. Independientemente de tus antecedentes o lenguaje de programación preferido, este capítulo es una <strong>lectura obligada</strong> para todo mundo.</p>
<div class="section" id="http-es-simple">
<h2>HTTP es Simple<a class="headerlink" href="#http-es-simple" title="Permalink to this headline">¶</a></h2>
<p>HTTP (&#8220;HyperText Transfer Protocol&#8221; para los apasionados y, en Español <em>Protocolo de transferencia hipertexto</em>) es un lenguaje de texto que permite a dos máquinas comunicarse entre sí. ¡Eso es todo! Por ejemplo, al comprobar las últimas noticias acerca de cómica <a class="reference external" href="http://xkcd.com/">xkcd</a>, la siguiente conversación (aproximadamente) se lleva a cabo:</p>
<img alt="images/http-xkcd-es.png" class="align-center" src="images/http-xkcd-es.png" />
<p>Y aunque el lenguaje real utilizado es un poco más formal, sigue siendo bastante simple.
HTTP es el término utilizado para describir este lenguaje simple basado en texto. Y no importa cómo desarrolles en la web, el objetivo de tu servidor <em>siempre</em> es entender las peticiones de texto simple, y devolver respuestas en texto simple.</p>
<p>Symfony2 está construido basado en torno a esa realidad. Ya sea que te des cuenta o no, HTTP es algo que usas todos los días. Con Symfony2, aprenderás a dominarlo.</p>
<div class="section" id="paso-1-el-cliente-envia-una-peticion">
<span id="index-1"></span><h3>Paso 1: El cliente envía una petición<a class="headerlink" href="#paso-1-el-cliente-envia-una-peticion" title="Permalink to this headline">¶</a></h3>
<p>Todas las conversaciones en la web comienzan con una <em>petición</em>. La petición es un mensaje de texto creado por un cliente (por ejemplo un navegador, una aplicación para el iPhone, etc.) en un formato especial conocido como HTTP. El cliente envía la petición a un servidor, y luego espera la respuesta.</p>
<p>Echa un vistazo a la primera parte de la interacción (la petición) entre un navegador y el servidor web <cite>xkcd</cite>:</p>
<img alt="images/http-xkcd-request-es.png" class="align-center" src="images/http-xkcd-request-es.png" />
<p>Hablando en HTTP, esta petición HTTP en realidad se vería algo parecida a esto:</p>
<div class="highlight-text"><div class="highlight"><pre>GET / HTTP/1.1
Host: xkcd.com
Accept: text/html
User-Agent: Mozilla/5.0 (Macintosh)
</pre></div>
</div>
<p>Este sencillo mensaje comunica <em>todo</em> lo necesario sobre qué recursos exactamente solicita el cliente. La primera línea de una petición HTTP es la más importante y contiene dos cosas: la URI y el método HTTP.</p>
<p>La URI (por ejemplo, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">/contacto</span></tt>, etc.) es la dirección o ubicación que identifica unívocamente al recurso que el cliente quiere. El método HTTP (por ejemplo, <tt class="docutils literal"><span class="pre">GET</span></tt>) define lo que quieres <em>hacer</em> con el recurso. Los métodos HTTP son los <em>verbos</em> de la petición y definen las pocas formas más comunes en que puedes actuar sobre el recurso:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr><td><em>GET</em></td>
<td>Recupera el recurso desde el servidor</td>
</tr>
<tr><td><em>POST</em></td>
<td>Crea un recurso en el servidor</td>
</tr>
<tr><td><em>PUT</em></td>
<td>Actualiza el recurso en el servidor</td>
</tr>
<tr><td><em>DELETE</em></td>
<td>Elimina el recurso del servidor</td>
</tr>
</tbody>
</table>
<p>Con esto en mente, te puedes imaginar que una petición HTTP podría ser similar a eliminar una entrada de blog específica, por ejemplo:</p>
<div class="highlight-text"><div class="highlight"><pre>DELETE /blog/15 HTTP/1.1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">En realidad, hay nueve métodos HTTP definidos por la especificación HTTP, pero muchos de ellos no se utilizan o apoyan ampliamente. En realidad, muchos navegadores modernos no apoyan los métodos <tt class="docutils literal"><span class="pre">PUT</span></tt> y <tt class="docutils literal"><span class="pre">DELETE</span></tt>.</p>
</div>
<p>Además de la primera línea, una petición HTTP invariablemente contiene otras líneas de información conocidas como cabeceras de petición. Las cabeceras pueden suministrar una amplia gama de información como el <tt class="docutils literal"><span class="pre">Host</span></tt> solicitado, los formatos de respuesta que acepta el cliente (<tt class="docutils literal"><span class="pre">Accept</span></tt>) y la aplicación que utiliza el cliente para realizar la petición (<tt class="docutils literal"><span class="pre">User-Agent</span></tt>). Existen muchas otras cabeceras y se pueden encontrar en el artículo <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">Lista de campos de las cabeceras HTTP</a> en la Wikipedia.</p>
</div>
<div class="section" id="paso-2-el-servidor-devuelve-una-respuesta">
<h3>Paso 2: El servidor devuelve una respuesta<a class="headerlink" href="#paso-2-el-servidor-devuelve-una-respuesta" title="Permalink to this headline">¶</a></h3>
<p>Una vez que un servidor ha recibido la petición, sabe exactamente qué recursos necesita el cliente (a través de la URI) y lo que el cliente quiere hacer con ese recurso (a través del método). Por ejemplo, en el caso de una petición GET, el servidor prepara el recurso y lo devuelve en una respuesta HTTP. Considera la respuesta del servidor web, xkcd:</p>
<img alt="images/http-xkcd-es.png" class="align-center" src="images/http-xkcd-es.png" />
<p>Traducida a HTTP, la respuesta enviada de vuelta al navegador se verá algo similar a esto:</p>
<div class="highlight-text"><div class="highlight"><pre>HTTP/1.1 200 OK
Date: Sat, 02 Apr 2011 21:05:05 GMT
Server: lighttpd/1.4.19
Content-Type: text/html

&lt;html&gt;
  &lt;!-- HTML para la caricatura xkcd --&gt;
&lt;/html&gt;
</pre></div>
</div>
<p>La respuesta HTTP contiene el recurso solicitado (contenido HTML en este caso), así como otra información acerca de la respuesta. La primera línea es especialmente importante y contiene el código de estado HTTP (200 en este caso) de la respuesta. El código de estado comunica el resultado global de la petición devuelto al cliente. ¿Tuvo éxito la petición? ¿Hubo algún error? Existen diferentes códigos de estado que indican éxito, un error o qué más se necesita hacer con el cliente (por ejemplo, redirigirlo a otra página). La lista completa se puede encontrar en el artículo <a class="reference external" href="http://es.wikipedia.org/wiki/Anexo:C%C3%B3digos_de_estado_HTTP">Lista de códigos de estado HTTP</a> en la Wikipedia.</p>
<p>Al igual que la petición, una respuesta HTTP contiene datos adicionales conocidos como cabeceras HTTP. Por ejemplo, una importante cabecera de la respuesta HTTP es <tt class="docutils literal"><span class="pre">Content-Type</span></tt>. El cuerpo del mismo recurso se puede devolver en múltiples formatos, incluyendo HTML, XML o JSON por nombrar unos cuantos. La cabecera <tt class="docutils literal"><span class="pre">Content-Type</span></tt> indica al cliente en qué formato se está devolviendo.</p>
<p>Existen muchas otras cabeceras, algunas de las cuales son muy poderosas. Por ejemplo, ciertas cabeceras se pueden usar para crear un poderoso sistema de memoria caché.</p>
</div>
<div class="section" id="peticiones-respuestas-y-desarrollo-web">
<h3>Peticiones, respuestas y desarrollo Web<a class="headerlink" href="#peticiones-respuestas-y-desarrollo-web" title="Permalink to this headline">¶</a></h3>
<p>Esta conversación petición-respuesta es el proceso fundamental que impulsa toda la comunicación en la web. Y tan importante y poderoso como es este proceso, inevitablemente es simple.</p>
<p>El hecho más importante es el siguiente: independientemente del lenguaje que utilices, el tipo de aplicación que construyas (web, móvil, API JSON), o la filosofía de desarrollo que sigas, el objetivo final de una aplicación siempre es <strong>entender</strong> cada petición y crear y devolver la respuesta adecuada.</p>
<p>Symfony está diseñado para adaptarse a esta realidad.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Para más información acerca de la especificación HTTP, lee la referencia original <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP 1.1 RFC</a> o <a class="reference external" href="http://datatracker.ietf.org/wg/httpbis/">HTTP Bis</a>, el cual es un esfuerzo activo para aclarar la especificación original. Una gran herramienta para comprobar tanto la petición como las cabeceras de la respuesta mientras navegas es la extensión <a class="reference external" href="https://addons.mozilla.org/en-US/firefox/addon/3829/">Cabeceras HTTP en vivo</a> (Live HTTP Headers) para Firefox.</p>
</div>
</div>
</div>
<div class="section" id="peticiones-y-respuestas-en-php">
<span id="index-2"></span><h2>Peticiones y respuestas en PHP<a class="headerlink" href="#peticiones-y-respuestas-en-php" title="Permalink to this headline">¶</a></h2>
<p>Entonces ¿cómo interactúas con la &#8220;petición&#8221; y creas una &#8220;respuesta&#8221; utilizando PHP? En realidad, PHP te abstrae un poco de todo el proceso:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$uri</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;REQUEST_URI&#39;</span><span class="p">];</span>
<span class="nv">$foo</span> <span class="o">=</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">];</span>

<span class="nb">header</span><span class="p">(</span><span class="s1">&#39;Content-type: text/html&#39;</span><span class="p">);</span>
<span class="k">echo</span> <span class="s1">&#39;La URI solicitada es: &#39;</span><span class="o">.</span><span class="nv">$uri</span><span class="p">;</span>
<span class="k">echo</span> <span class="s1">&#39;El valor del parámetro &quot;foo&quot; es: &#39;</span><span class="o">.</span><span class="nv">$foo</span><span class="p">;</span>
</pre></div>
</div>
<p>Por extraño que parezca, esta pequeña aplicación, de hecho, está tomando información de la petición HTTP y la utiliza para crear una respuesta HTTP. En lugar de analizar el mensaje HTTP de la petición, PHP prepara variables superglobales tales como <tt class="docutils literal"><span class="pre">$_SERVER</span></tt> y <tt class="docutils literal"><span class="pre">$_GET</span></tt> que contienen toda la información de la petición. Del mismo modo, en lugar de devolver la respuesta HTTP con formato de texto, puedes usar la función <tt class="docutils literal"><span class="pre">header()</span></tt> para crear las cabeceras de la respuesta y simplemente imprimir el contenido real que será la porción que contiene el mensaje de la respuesta. PHP creará una verdadera respuesta HTTP y la devolverá al cliente:</p>
<div class="highlight-text"><div class="highlight"><pre>HTTP/1.1 200 OK
Date: Sat, 03 Apr 2011 02:14:33 GMT
Server: Apache/2.2.17 (Unix)
Content-Type: text/html

La URI solicitada es: /probando?foo=symfony
El valor del parámetro &quot;foo&quot; es: symfony
</pre></div>
</div>
</div>
<div class="section" id="peticiones-y-respuestas-en-symfony">
<h2>Peticiones y respuestas en Symfony<a class="headerlink" href="#peticiones-y-respuestas-en-symfony" title="Permalink to this headline">¶</a></h2>
<p>Symfony ofrece una alternativa al enfoque de PHP a través de dos clases que te permiten interactuar con la petición HTTP y la respuesta de una manera más fácil.
La clase <tt class="xref py py-class docutils literal"><span class="pre">Symfony\Component\HttpFoundation\Request</span></tt> es una sencilla representación orientada a objeto del mensaje de la petición HTTP. Con ella, tienes toda la información a tu alcance:</p>
<div class="highlight-python"><pre>use Symfony\Component\HttpFoundation\Request;

$peticion = Request::createFromGlobals();

// la URI solicitada (por ejemplo, /sobre) menos los parámetros de la consulta
$peticion-&gt;getPathInfo();

// recupera las variables GET y POST respectivamente
$peticion-&gt;query-&gt;get('foo');
$peticion-&gt;request-&gt;get('bar');

// recupera una instancia del archivo subido identificado por foo
$peticion-&gt;files-&gt;get('foo');

$peticion-&gt;getMethod();          // GET, POST, PUT, DELETE, HEAD
$peticion-&gt;getLanguages();       // un arreglo de idiomas aceptados por el cliente</pre>
</div>
<p>Como bono adicional, en el fondo la clase <tt class="docutils literal"><span class="pre">Petición</span></tt> hace un montón de trabajo del cual nunca tendrás que preocuparte. Por ejemplo, el método <tt class="docutils literal"><span class="pre">isSecure()</span></tt> comprueba <em>tres</em> diferentes valores en PHP que pueden indicar si el usuario está conectado a través de una conexión segura (es decir, <tt class="docutils literal"><span class="pre">https</span></tt>).</p>
<p>Symfony también proporciona una clase <tt class="docutils literal"><span class="pre">Respuesta</span></tt>: una simple representación PHP de un mensaje de respuesta HTTP. Esto permite que tu aplicación utilice una interfaz orientada a objetos para construir la respuesta que será devuelta al cliente:</p>
<div class="highlight-python"><pre>use Symfony\Component\HttpFoundation\Response;
$respuesta = new Response();

$respuesta-&gt;setContent('&lt;html&gt;&lt;body&gt;&lt;h1&gt;¡Hola mundo!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');
$respuesta-&gt;setStatusCode(200);
$respuesta-&gt;headers-&gt;set('Content-Type', 'text/html');

// imprime las cabeceras HTTP seguidas por el contenido
$respuesta-&gt;send();</pre>
</div>
<p>Si Symfony no ofreciera nada más, ya tendrías un conjunto de herramientas para acceder fácilmente a la información de la petición y una interfaz orientada a objetos para crear la respuesta. Incluso, a medida que aprendas muchas de las poderosas características de Symfony, nunca olvides que el objetivo de tu aplicación es <em>interpretar una petición y crear la respuesta apropiada basada en la lógica de tu aplicación</em>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Las clases <tt class="docutils literal"><span class="pre">Respuesta</span></tt> y <tt class="docutils literal"><span class="pre">Petición</span></tt> forman parte de un componente independiente incluido en Symfony llamado <tt class="docutils literal"><span class="pre">HttpFoundation</span></tt>. Este componente se puede utilizar completamente independiente de Symfony y también proporciona clases para manejar sesiones y subir archivos.</p>
</div>
</div>
<div class="section" id="el-viaje-desde-la-peticion-hasta-la-respuesta">
<h2>El viaje desde la petición hasta la respuesta<a class="headerlink" href="#el-viaje-desde-la-peticion-hasta-la-respuesta" title="Permalink to this headline">¶</a></h2>
<p>Al igual que el mismo HTTP, los objetos <tt class="docutils literal"><span class="pre">Petición</span></tt> y <tt class="docutils literal"><span class="pre">Respuesta</span></tt> son bastante simples.
La parte difícil de la construcción de una petición es escribir lo que viene en el medio.
En otras palabras, el verdadero trabajo viene al escribir el código que interpreta la información de la petición y crea la respuesta.</p>
<p>Tu aplicación probablemente hace muchas cosas, como enviar correo electrónico, manejar los formularios presentados, guardar cosas en una base de datos, reproducir las páginas HTML y proteger el contenido con seguridad. ¿Cómo puedes manejar todo esto y todavía mantener tu código organizado y fácil de mantener?</p>
<p>Symfony fue creado para resolver estos problemas para que no tengas que hacerlo personalmente.</p>
<div class="section" id="el-controlador-frontal">
<h3>El controlador frontal<a class="headerlink" href="#el-controlador-frontal" title="Permalink to this headline">¶</a></h3>
<p>Tradicionalmente, las aplicaciones eran construidas de modo que cada &#8220;página&#8221; de un sitio tenía su propio archivo físico:</p>
<div class="highlight-text"><div class="highlight"><pre>index.php
contacto.php
blog.php
</pre></div>
</div>
<p>Hay varios problemas con este enfoque, incluyendo la falta de flexibilidad de las URL (¿qué pasa si quieres cambiar <tt class="docutils literal"><span class="pre">blog.php</span></tt> a <tt class="docutils literal"><span class="pre">noticias.php</span></tt> sin romper todos los vínculos?) y el hecho de que cada archivo <em>debe</em> incluir manualmente un conjunto de archivos básicos para la seguridad, conexiones a base de datos y que el &#8220;aspecto&#8221; del sitio pueda permanecer constante.</p>
<p>Una solución mucho mejor es usar un <a class="reference internal" href="../glossary.html#term-controlador-frontal"><em class="xref std std-term">controlador frontal</em></a>: un solo archivo PHP que se encargue de todas las peticiones que llegan a tu aplicación. Por ejemplo:</p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="49%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">/index.php</span></tt></td>
<td>ejecuta <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">/index.php/contacto</span></tt></td>
<td>ejecuta <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">/index.php/blog</span></tt></td>
<td>ejecuta <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Usando <tt class="docutils literal"><span class="pre">mod_rewrite</span></tt> de Apache (o equivalente con otros servidores web), las direcciones URL se pueden limpiar fácilmente hasta ser sólo <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">/contacto</span></tt> y <tt class="docutils literal"><span class="pre">/blog</span></tt>.</p>
</div>
<p>Ahora, cada petición se maneja exactamente igual. En lugar de direcciones URL individuales ejecutando diferentes archivos PHP, el controlador frontal <em>siempre</em> se ejecuta, y el enrutado de diferentes direcciones URL a diferentes partes de tu aplicación se realiza internamente. Esto resuelve los problemas del enfoque original.
Casi todas las aplicaciones web modernas lo hacen - incluyendo aplicaciones como WordPress.</p>
</div>
<div class="section" id="mantente-organizado">
<h3>Mantente organizado<a class="headerlink" href="#mantente-organizado" title="Permalink to this headline">¶</a></h3>
<p>Pero dentro de tu controlador frontal, ¿cómo sabes qué página debe reproducir y cómo puedes reproducir cada una en forma sana? De una forma u otra, tendrás que comprobar la URI entrante y ejecutar diferentes partes de tu código en función de ese valor. Esto se puede poner feo rápidamente:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">// index.php</span>

<span class="x">$peticion = Request::createFromGlobals();</span>
<span class="x">$ruta = $peticion-&gt;getPathInfo(); // la URL solicitada</span>

<span class="x">if (in_array($ruta, array(&#39;&#39;, &#39;/&#39;)) {</span>
<span class="x">    $respuesta = new Response(&#39;Bienvenido a la página inicial.&#39;);</span>
<span class="x">} elseif ($ruta == &#39;/contacto&#39;) {</span>
<span class="x">    $respuesta = new Response(&#39;Contáctanos&#39;);</span>
<span class="x">} else {</span>
<span class="x">    $respuesta = new Response(&#39;Página no encontrada.&#39;, 404);</span>
<span class="x">}</span>
<span class="x">$respuesta-&gt;send();</span>
</pre></div>
</div>
<p>La solución a este problema puede ser difícil. Afortunadamente esto es <em>exactamente</em> para lo que Symfony está diseñado.</p>
</div>
<div class="section" id="el-flujo-de-las-aplicaciones-symfony">
<h3>El flujo de las aplicaciones Symfony<a class="headerlink" href="#el-flujo-de-las-aplicaciones-symfony" title="Permalink to this headline">¶</a></h3>
<p>Cuando dejas que Symfony controle cada petición, la vida es mucho más fácil. Symfony sigue el mismo patrón simple en cada petición:</p>
<div class="figure align-center" id="request-flow-figure">
<img alt="flujo de la petición en Symfony2" src="../_images/flujo-peticion.png" />
<p class="caption">Las peticiones entrantes son interpretadas por el enrutador y pasadas a las funciones controladoras que regresan objetos <tt class="docutils literal"><span class="pre">Respuesta</span></tt>.</p>
</div>
<p>Cada &#8220;página&#8221; de tu sitio está definida en un archivo de configuración de enrutado que asigna las diferentes direcciones URL a diferentes funciones PHP. El trabajo de cada función PHP conocida como <a class="reference internal" href="../glossary.html#term-controlador"><em class="xref std std-term">controlador</em></a>, es utilizar la información de la petición - junto con muchas otras herramientas que Symfony pone a tu disposición - para crear y devolver un objeto <tt class="docutils literal"><span class="pre">Respuesta</span></tt>. En otras palabras, el controlador es donde <em>está tu</em> código: ahí es dónde se interpreta la petición y crea una respuesta.</p>
<p>¡Así de fácil! Repasemos:</p>
<ul class="simple">
<li>Cada petición ejecuta un archivo controlador frontal;</li>
<li>El sistema de enrutado determina cual función PHP se debe ejecutar en base a la información de la petición y la configuración de enrutado que hemos creado;</li>
<li>La función PHP correcta se ejecuta, donde tu código crea y devuelve el objeto <tt class="docutils literal"><span class="pre">Respuesta</span></tt> adecuado.</li>
</ul>
</div>
<div class="section" id="una-peticion-symfony-en-accion">
<h3>Una petición Symfony en acción<a class="headerlink" href="#una-peticion-symfony-en-accion" title="Permalink to this headline">¶</a></h3>
<p>Sin bucear demasiado en los detalles, veamos este proceso en acción. Supongamos que deseas agregar una página <tt class="docutils literal"><span class="pre">/contacto</span></tt> a tu aplicación Symfony. En primer lugar, empezamos agregando una entrada <tt class="docutils literal"><span class="pre">/contacto</span></tt> a tu archivo de configuración de enrutado:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">contacto</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">pattern</span><span class="p-Indicator">:</span>  <span class="l-Scalar-Plain">/contacto</span>
    <span class="l-Scalar-Plain">defaults</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">_controller</span><span class="p-Indicator">:</span> <span class="nv">AcmeDemoBundle</span><span class="p-Indicator">:</span><span class="nv">Principal</span><span class="p-Indicator">:</span><span class="nv">contacto</span> <span class="p-Indicator">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">En este ejemplo utilizamos <a class="reference internal" href="../reference/YAML.html"><em>YAML</em></a> para definir la configuración de enrutado.
La configuración de enrutado también se puede escribir en otros formatos como XML o PHP.</p>
</div>
<p>Cuando alguien visita la página <tt class="docutils literal"><span class="pre">/contacto</span></tt>, esta ruta coincide, y se ejecuta el controlador especificado. Como veremos en el capítulo <a class="reference internal" href="routing.html"><em>Enrutando</em></a>, La cadena <tt class="docutils literal"><span class="pre">AcmeDemoBundle:Principal:contacto</span></tt> es una sintaxis corta que apunta hacia el método PHP <tt class="docutils literal"><span class="pre">contactoAction</span></tt> dentro de una clase llamada <tt class="docutils literal"><span class="pre">PrincipalController</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">class PrincipalController</span>
<span class="x">{</span>
<span class="x">    public function contactoAction()</span>
<span class="x">    {</span>
<span class="x">        return new Response(&#39;&lt;h1&gt;¡Contáctanos!&lt;/h1&gt;&#39;);</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>En este ejemplo muy simple, el controlador simplemente crea un objeto <tt class="docutils literal"><span class="pre">Respuesta</span></tt> con el código HTML &#8220;&lt;h1&gt;¡Contáctanos!&lt;/h1&gt;&#8221;. En el capítulo <a class="reference internal" href="controller.html"><em>Controlador</em></a>, aprenderás cómo un controlador puede reproducir plantillas, permitiendo que tu código de &#8220;presentación&#8221; (es decir, algo que en realidad escribe HTML) viva en un archivo de plantilla separado. Esto libera al controlador de preocuparse sólo de las cosas difíciles: la interacción con la base de datos, la manipulación de los datos presentados o el envío de mensajes de correo electrónico.</p>
</div>
</div>
<div class="section" id="symfony2-construye-tu-aplicacion-no-tus-herramientas">
<h2>Symfony2: Construye tu aplicación, no tus herramientas.<a class="headerlink" href="#symfony2-construye-tu-aplicacion-no-tus-herramientas" title="Permalink to this headline">¶</a></h2>
<p>Ahora sabemos que el objetivo de cualquier aplicación es interpretar cada petición entrante y crear una respuesta adecuada. Cuando una aplicación crece, es más difícil mantener organizado tu código y que a la vez sea fácil darle mantenimiento. Invariablemente, las mismas tareas complejas siguen viniendo una y otra vez: la persistencia de cosas en la base de datos, procesamiento y reutilización de plantillas, manejo de formularios presentados, envío de mensajes de correo electrónico, validación de entradas del usuario y administración de la seguridad.</p>
<p>La buena nueva es que ninguno de estos problemas es único. Symfony proporciona una plataforma completa, con herramientas que te permiten construir tu aplicación, no tus herramientas. Con Symfony2, nada se te impone: eres libre de usar la plataforma Symfony completa, o simplemente una pieza de Symfony por sí misma.</p>
<div class="section" id="herramientas-independientes-componentes-de-symfony2">
<span id="index-3"></span><h3>Herramientas independientes: <em>Componentes</em> de Symfony2<a class="headerlink" href="#herramientas-independientes-componentes-de-symfony2" title="Permalink to this headline">¶</a></h3>
<p>Entonces, ¿qué <em>es</em> Symfony2? En primer lugar, Symfony2 es una colección de más de veinte bibliotecas independientes que se pueden utilizar dentro de <em>cualquier</em> proyecto PHP. Estas bibliotecas, llamadas <em>componentes de Symfony2</em>, contienen algo útil para casi cualquier situación, independientemente de cómo desarrolles tu proyecto. Para nombrar algunos:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/symfony/HttpFoundation">HttpFoundation</a> - Contiene las clases <tt class="docutils literal"><span class="pre">Petición</span></tt> y <tt class="docutils literal"><span class="pre">Respuesta</span></tt>, así como otras clases para manejar sesiones y carga de archivos;</li>
<li><a class="reference external" href="https://github.com/symfony/Routing">Routing</a> - Potente y rápido sistema de enrutado que te permite asignar una URI específica (por ejemplo <tt class="docutils literal"><span class="pre">/contacto</span></tt>) a cierta información acerca de cómo dicha petición se debe manejar (por ejemplo, ejecutar el método <tt class="docutils literal"><span class="pre">contactoAction()</span></tt>);</li>
<li><a class="reference external" href="https://github.com/symfony/Form">Form</a> - Una completa y flexible plataforma para crear formularios y manipular la presentación de los mismos;</li>
<li><a class="reference external" href="https://github.com/symfony/Validator">Validator</a> Un sistema para crear reglas sobre datos y cuando el usuario envía los datos validar o no siguiendo esas reglas;</li>
<li><a class="reference external" href="https://github.com/symfony/ClassLoader">ClassLoader</a> Una biblioteca para carga automática que permite utilizar clases PHP sin necesidad de <tt class="docutils literal"><span class="pre">requerir</span></tt> manualmente los archivos que contienen esas clases;</li>
<li><a class="reference external" href="https://github.com/symfony/Templating">Templating</a> Un juego de herramientas para reproducir plantillas, la cual gestiona la herencia de plantillas (es decir, una plantilla está decorada con un diseño) y realiza otras tareas de plantilla comunes;</li>
<li><a class="reference external" href="https://github.com/symfony/Security">Security</a> - Una poderosa biblioteca para manejar todo tipo de seguridad dentro de una aplicación;</li>
<li><a class="reference external" href="https://github.com/symfony/Translation">Translation</a> Una plataforma para traducir cadenas en tu aplicación.</li>
</ul>
<p>Todos y cada uno de estos componentes se desacoplan y se pueden utilizar en <em>cualquier</em> proyecto PHP, independientemente de si utilizas la plataforma Symfony2.
Cada parte está hecha para utilizarla si es conveniente y sustituirse cuando sea necesario.</p>
</div>
<div class="section" id="la-solucion-completa-la-plataforma-symfony2">
<h3>La solución completa: La <em>plataforma</em> Symfony2<a class="headerlink" href="#la-solucion-completa-la-plataforma-symfony2" title="Permalink to this headline">¶</a></h3>
<p>Entonces, ¿qué <em>es</em> la <em>plataforma</em> Symfony2? La <em>plataforma</em> Symfony2 es una biblioteca PHP que realiza dos distintas tareas:</p>
<ol class="arabic simple">
<li>Proporciona una selección de componentes (es decir, los componentes Symfony2) y bibliotecas de terceros (por ejemplo, <tt class="docutils literal"><span class="pre">SwiftMailer</span></tt> para enviar mensajes de correo electrónico);</li>
<li>Proporciona configuración sensible y un &#8220;pegamento&#8221; que une la biblioteca con todas estas piezas.</li>
</ol>
<p>El objetivo de la plataforma es integrar muchas herramientas independientes con el fin de proporcionar una experiencia coherente al desarrollador. Incluso la propia plataforma es un paquete Symfony2 (es decir, un complemento) que se puede configurar o sustituir completamente.</p>
<p>Symfony2 proporciona un potente conjunto de herramientas para desarrollar aplicaciones web rápidamente sin imponerse en tu aplicación. Los usuarios normales rápidamente pueden comenzar el desarrollo usando una distribución Symfony2, que proporciona un esqueleto del proyecto con parámetros predeterminados. Para los usuarios más avanzados, el cielo es el límite.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Symfony2 y fundamentos HTTP</a><ul>
<li><a class="reference internal" href="#http-es-simple">HTTP es Simple</a><ul>
<li><a class="reference internal" href="#paso-1-el-cliente-envia-una-peticion">Paso 1: El cliente envía una petición</a></li>
<li><a class="reference internal" href="#paso-2-el-servidor-devuelve-una-respuesta">Paso 2: El servidor devuelve una respuesta</a></li>
<li><a class="reference internal" href="#peticiones-respuestas-y-desarrollo-web">Peticiones, respuestas y desarrollo Web</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peticiones-y-respuestas-en-php">Peticiones y respuestas en PHP</a></li>
<li><a class="reference internal" href="#peticiones-y-respuestas-en-symfony">Peticiones y respuestas en Symfony</a></li>
<li><a class="reference internal" href="#el-viaje-desde-la-peticion-hasta-la-respuesta">El viaje desde la petición hasta la respuesta</a><ul>
<li><a class="reference internal" href="#el-controlador-frontal">El controlador frontal</a></li>
<li><a class="reference internal" href="#mantente-organizado">Mantente organizado</a></li>
<li><a class="reference internal" href="#el-flujo-de-las-aplicaciones-symfony">El flujo de las aplicaciones Symfony</a></li>
<li><a class="reference internal" href="#una-peticion-symfony-en-accion">Una petición Symfony en acción</a></li>
</ul>
</li>
<li><a class="reference internal" href="#symfony2-construye-tu-aplicacion-no-tus-herramientas">Symfony2: Construye tu aplicación, no tus herramientas.</a><ul>
<li><a class="reference internal" href="#herramientas-independientes-componentes-de-symfony2">Herramientas independientes: <em>Componentes</em> de Symfony2</a></li>
<li><a class="reference internal" href="#la-solucion-completa-la-plataforma-symfony2">La solución completa: La <em>plataforma</em> Symfony2</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Libro</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="from_flat_php_to_symfony2.html"
                        title="next chapter">Symfony2 frente a PHP simple</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/book/http_fundamentals.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="from_flat_php_to_symfony2.html" title="Symfony2 frente a PHP simple"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Libro"
             >previous</a> |</li>
        <li><a href="../index.html">symfony-docs-es v1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Libro</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Osukaru.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>