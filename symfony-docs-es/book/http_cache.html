

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Caché HTTP &mdash; symfony-docs-es v1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="symfony-docs-es v1 documentation" href="../index.html" />
    <link rel="up" title="Libro" href="index.html" />
    <link rel="next" title="Traduciendo" href="translation.html" />
    <link rel="prev" title="Seguridad" href="security.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="translation.html" title="Traduciendo"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="security.html" title="Seguridad"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">symfony-docs-es v1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Libro</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cache-http">
<span id="index-0"></span><h1>Caché HTTP<a class="headerlink" href="#cache-http" title="Permalink to this headline">¶</a></h1>
<p>La naturaleza de las aplicaciones web ricas significa que son dinámicas. No importa qué tan eficiente sea tu aplicación, cada petición siempre contendrá más sobrecarga que servir un archivo estático.</p>
<p>Y para la mayoría de las aplicaciones Web, está bien. Symfony2 es tan rápido como el rayo, a menos que estés haciendo una muy complicada aplicación, cada petición se responderá rápidamente sin poner demasiada tensión a tu servidor.</p>
<p>Pero cuando tu sitio crezca, la sobrecarga general se puede convertir en un problema. El procesamiento que se realiza normalmente en cada petición se debe hacer sólo una vez. Este exactamente es el objetivo que tiene que consumar la memoria caché.</p>
<div class="section" id="la-memoria-cache-en-hombros-de-gigantes">
<h2>La memoria caché en hombros de gigantes<a class="headerlink" href="#la-memoria-cache-en-hombros-de-gigantes" title="Permalink to this headline">¶</a></h2>
<p>La manera más efectiva para mejorar el rendimiento de una aplicación es memorizar en caché la salida completa de una página y luego eludir por completo la aplicación en cada petición posterior. Por supuesto, esto no siempre es posible para los sitios web altamente dinámicos, ¿o no? En este capítulo, te mostraremos cómo funciona el sistema de caché Symfony2 y por qué pensamos que este es el mejor enfoque posible.</p>
<p>El sistema de cache Symfony2 es diferente porque se basa en la simplicidad y el poder de la caché HTTP tal como está definido en la <a class="reference internal" href="../glossary.html#term-especificacion-http"><em class="xref std std-term">especificación HTTP</em></a>.
En lugar de reinventar una metodología de memoria caché, Symfony2 adopta la norma que define la comunicación básica en la Web. Una vez que comprendas los principios fundamentales de los modelos de caducidad y validación de la memoria caché HTTP, estarás listo para dominar el sistema de caché Symfony2.</p>
<p>Para efectos de aprender cómo guardar en caché con Symfony2, vamos a cubrir el tema en cuatro pasos:</p>
<ul class="simple">
<li><strong>Paso 1</strong>: Una <a class="reference internal" href="#gateway-caches"><em>pasarela de caché</em></a>, o sustituto inverso, es una capa independiente situada frente a tu aplicación. La caché del sustituto inverso responde a medida que son devueltas desde tu aplicación y responde a peticiones con respuestas de la caché antes de que lleguen a tu aplicación. Symfony2 proporciona su propio sustituto inverso, pero puedes utilizar cualquier sustituto inverso.</li>
<li><strong>Paso 2</strong> <a class="reference internal" href="#http-cache-introduction"><em>cache HTTP</em></a> las cabeceras se utilizan para comunicarse con la pasarela de caché y cualquier otro caché entre la aplicación y el cliente. Symfony2 proporciona parámetros predeterminados y una potente interfaz para interactuar con las cabeceras de caché.</li>
<li><strong>Paso 3</strong>: HTTP <a class="reference internal" href="#http-expiration-validation"><em>caducidad y validación</em></a> son los dos modelos utilizados para determinar si el contenido memorizado en caché es <em>fresco</em> (se puede reutilizar de la memoria caché) u <em>obsoleto</em> (lo debe regenerar la aplicación).</li>
<li><strong>Paso 4</strong> : <a class="reference internal" href="#edge-side-includes"><em>Inclusión del borde lateral</em></a> (Edge Side Includes -<a href="#id5"><span class="problematic" id="id6">|ESI|</span></a>) permite que la caché HTTP utilice fragmentos de la página en caché (incluso fragmentos anidados) independientemente.
Con <a href="#id7"><span class="problematic" id="id8">|ESI|</span></a>, incluso puedes guardar en caché una página entera durante 60 minutos, pero una barra lateral integrada sólo por 5 minutos.</li>
</ul>
<p>Dado que la memoria caché HTTP no es exclusiva de Symfony, ya existen muchos artículos sobre el tema. Si eres nuevo para la memoria caché HTTP, te <em>recomendamos</em> el artículo de Ryan Tomayko <a class="reference external" href="http://tomayko.com/writings/things-caches-do">Things Caches Do</a>. Otro recurso en profundidad es la <a class="reference external" href="http://www.mnot.net/cache_docs/">Guía de caché</a> de Mark Nottingham.</p>
</div>
<div class="section" id="memoria-cache-con-pasarela-de-cache">
<span id="gateway-caches"></span><span id="index-1"></span><h2>Memoria caché con pasarela de caché<a class="headerlink" href="#memoria-cache-con-pasarela-de-cache" title="Permalink to this headline">¶</a></h2>
<p>Cuándo memorizar caché con HTTP, la <em>caché</em> está separada de tu aplicación por completo y se sitúa entre tu aplicación y el cliente haciendo la petición.</p>
<p>El trabajo de la caché es aceptar las peticiones del cliente y pasarlas de nuevo a tu aplicación. La memoria caché también recibirá las respuestas devueltas por tu aplicación y las remitirá al cliente. La caché es el &#8220;geniecillo&#8221; de la comunicación petición-respuesta entre el cliente y tu aplicación.</p>
<p>En el camino, la memoria caché almacena cada respuesta que se considere &#8220;cacheable&#8221; (consulta <a class="reference internal" href="#http-cache-introduction"><em>Introducción a la memoria caché HTTP</em></a>). Si de nuevo se solicita el mismo recurso, la memoria caché envía la respuesta memorizada en caché al cliente, eludiendo tu aplicación por completo.</p>
<p>Este tipo de caché se conoce como caché de puerta de enlace HTTP y existen muchos como <a class="reference external" href="http://www.varnish-cache.org/">Varnish</a>, <a class="reference external" href="http://wiki.squid-cache.org/SquidFaq/ReverseProxy">Squid en modo sustituto inverso</a> y el sustituto inverso de Symfony2.</p>
<div class="section" id="tipos-de-cache">
<span id="index-2"></span><h3>Tipos de Caché<a class="headerlink" href="#tipos-de-cache" title="Permalink to this headline">¶</a></h3>
<p>Sin embargo, una puerta de enlace caché no es el único tipo de caché. De hecho, las cabeceras de caché HTTP enviadas por tu aplicación son consumidas e interpretadas por un máximo de tres diferentes tipos de caché:</p>
<ul class="simple">
<li><em>Caché de navegadores</em>: Cada navegador viene con su propia caché local que es realmente útil para cuando pulsas &#8220;atrás&#8221; o en imágenes y otros activos.
La caché del navegador es una caché <em>privada</em>, los recursos memorizados en caché no se comparten con nadie más.</li>
<li><em>Cachés sustitutas</em>: Una sustituta es una caché <em>compartida</em> en que muchas personas pueden estar detrás de una sola. Por lo general instalada por las grandes corporaciones y proveedores de Internet para reducir latencia y tráfico de red.</li>
<li><em>Pasarelas de caché</em>: Al igual que un sustituto, también es una caché <em>compartida</em> pero de lado del servidor. Instalada por los administradores de red, esta tiene sitios web más escalables, confiables y prácticos.</li>
</ul>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Las pasarelas de caché a veces se conocen como caché sustituta inversa, cachés alquiladas o incluso aceleradores HTTP.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">La importancia de la caché <em>privada</em> frente a la <em>compartida</em> será más evidente a medida que hablemos de las respuestas en la memoria caché con contenido que es específico para un solo usuario (por ejemplo, información de cuenta).</p>
</div>
<p>Cada respuesta de tu aplicación probablemente vaya a través de uno o los dos primeros tipos de caché. Estas cachés están fuera de tu control, pero siguen las instrucciones de caché HTTP establecidas en la respuesta.</p>
</div>
<div class="section" id="sustituto-inverso-de-symfony2">
<span id="symfony-gateway-cache"></span><span id="index-3"></span><h3>Sustituto inverso de Symfony2<a class="headerlink" href="#sustituto-inverso-de-symfony2" title="Permalink to this headline">¶</a></h3>
<p>Symfony2 viene con una caché sustituta inversa (también llamada memoria caché de puerta de enlace) escrita en PHP. Que al activarlo, inmediatamente puede memorizar en caché respuestas de tu aplicación. La instalación es muy fácil. Cada nueva aplicación Symfony2 viene con un núcleo preconfigurado memorizado en caché (<tt class="docutils literal"><span class="pre">AppCache</span></tt>) que envuelve el (<tt class="docutils literal"><span class="pre">AppKernel</span></tt>) predeterminado. La memoria caché del núcleo <em>es</em> el sustituto inverso.</p>
<p>Para habilitar la memoria caché, modifica el código de un controlador frontal para utilizar la memoria caché del núcleo:</p>
<div class="highlight-python"><pre>// web/app.php

require_once __DIR__.'/../app/bootstrap_cache.php.cache';
require_once __DIR__.'/../app/AppCache.php';

use Symfony\Component\HttpFoundation\Request;

// pone el AppKernel predeterminado con un AppCache
$kernel = new AppCache(new AppKernel('prod', false));
$kernel-&gt;handle(Request::createFromGlobals())-&gt;send();</pre>
</div>
<p>La memoria caché del núcleo actúa de inmediato como un sustituto inverso - memorizando en caché las respuestas de tu aplicación y devolviéndolas al cliente.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>La caché del núcleo tiene un método especial <cite>getLog()</cite>, el cual devuelve una cadena que representa lo que sucedió en la capa de la caché. En el entorno de desarrollo, se usa para depurar y validar la estrategia de caché:</p>
<div class="last highlight-python"><pre>error_log($kernel-&gt;getLog());</pre>
</div>
</div>
<p>El objeto <tt class="docutils literal"><span class="pre">AppCache</span></tt> tiene una configuración predeterminada sensible, pero la puedes afinar por medio de un conjunto de opciones que puedes configurar sustituyendo el método <tt class="docutils literal"><span class="pre">getOptions()</span></tt>:</p>
<div class="highlight-python"><pre>// app/AppCache.php
class AppCache extends Cache
{
    protected function getOptions()
    {
        return array(
            'debug'                  =&gt; false,
            'default_ttl'            =&gt; 0,
            'private_headers'        =&gt; array('Authorization', 'Cookie'),
            'allow_reload'           =&gt; false,
            'allow_revalidate'       =&gt; false,
            'stale_while_revalidate' =&gt; 2,
            'stale_if_error'         =&gt; 60,
        );
    }
}</pre>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">A menos que la sustituyas en <tt class="docutils literal"><span class="pre">getOptions()</span></tt>, la opción <tt class="docutils literal"><span class="pre">debug</span></tt> se establecerá automáticamente al valor de depuración del <tt class="docutils literal"><span class="pre">AppKernel</span></tt> envuelto.</p>
</div>
<p>Aquí está una lista de las principales opciones:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">default_ttl</span></tt>: El número de segundos que una entrada de caché se debe considerar nueva cuando no hay información fresca proporcionada explícitamente en una respuesta. Las cabeceras explícitas <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> o <tt class="docutils literal"><span class="pre">Expires</span></tt> sustituyen este valor (predeterminado: <tt class="docutils literal"><span class="pre">0</span></tt>);</li>
<li><tt class="docutils literal"><span class="pre">private_headers</span></tt>: Conjunto de cabeceras de la petición que desencadenan el comportamiento &#8220;privado&#8221; <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> en las respuestas en que la respuesta explícitamente no es <tt class="docutils literal"><span class="pre">pública</span></tt> o <tt class="docutils literal"><span class="pre">privada</span></tt> vía una directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>.
(predeterminado: <tt class="docutils literal"><span class="pre">Authorization</span></tt> y <tt class="docutils literal"><span class="pre">Cookie</span></tt>);</li>
<li><tt class="docutils literal"><span class="pre">allow_reload</span></tt>: Especifica si el cliente puede forzar una recarga desde caché incluyendo una directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> &#8220;no-cache&#8221; en la petición. Selecciona <tt class="docutils literal"><span class="pre">true</span></tt> para cumplir con la RFC 2616 (por omisión: <tt class="docutils literal"><span class="pre">false</span></tt>);</li>
<li><tt class="docutils literal"><span class="pre">allow_revalidate</span></tt>: Especifica si el cliente puede forzar una revalidación de caché incluyendo una directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> <tt class="docutils literal"><span class="pre">max-age</span> <span class="pre">=</span> <span class="pre">0</span></tt> en la petición. Selecciona <tt class="docutils literal"><span class="pre">true</span></tt> para cumplir con la RFC 2616 (por omisión: <tt class="docutils literal"><span class="pre">false</span></tt>);</li>
<li><tt class="docutils literal"><span class="pre">stale_while_revalidate</span></tt>: Especifica el número predeterminado de segundos (la granularidad es el segundo como la precisión de respuesta TTL es un segundo) en el que la memoria caché puede regresar inmediatamente una respuesta obsoleta mientras que revalida en el fondo (por omisión: <tt class="docutils literal"><span class="pre">2</span></tt>), este valor lo reemplaza <tt class="docutils literal"><span class="pre">stale-while-revalidate</span></tt> de la extensión HTTP <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> (consulta la RFC 5.861);</li>
<li><tt class="docutils literal"><span class="pre">stale_if_error</span></tt>: Especifica el número de segundos predeterminado (la granularidad es el segundo) durante el cual la caché puede servir una respuesta obsoleta cuando se detecta un error (por omisión: <tt class="docutils literal"><span class="pre">60</span></tt>). Este valor lo reemplaza <tt class="docutils literal"><span class="pre">stale-if-error</span></tt> de la extensión HTTP <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> (consulta la RFC 5861).</li>
</ul>
<p>Si <tt class="docutils literal"><span class="pre">debug</span></tt> es <tt class="docutils literal"><span class="pre">true</span></tt>, Symfony2 automáticamente agrega una cabecera <tt class="docutils literal"><span class="pre">X-Symfony-Cache</span></tt> a la respuesta que contiene información útil acerca de aciertos y errores de caché.</p>
<div class="sidebar">
<p class="first sidebar-title">Cambiando de un sustituto inverso a otro</p>
<p>El sustituto inverso de Symfony2 es una gran herramienta a utilizar en el desarrollo de tu sitio web o al desplegar tu web en un servidor compartido donde no puedes instalar nada más allá que código PHP. Pero está escrito en PHP, no puede ser tan rápido como un sustituto escrito en C. Es por eso que recomendamos usar Vanish o Squid en tus servidores de producción de ser posible. La buena nueva es que el cambio de un servidor sustituto a otro es fácil y transparente, sin modificar el código necesario en tu aplicación. Comienza fácilmente con el sustituto inverso de Symfony2 y actualiza a Varnish cuando aumente el tráfico.</p>
<p class="last">Para más información sobre el uso de Varnish con Symfony2, consulta el capítulo <a class="reference internal" href="../cookbook/cache/varnish.html"><em>Cómo usar Varnish</em></a> del recetario.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">El rendimiento del sustituto inverso de Symfony2 es independiente de la complejidad de tu aplicación. Eso es porque el núcleo de tu aplicación sólo se inicia cuando la petición se debe remitir a ella.</p>
</div>
</div>
</div>
<div class="section" id="introduccion-a-la-memoria-cache-http">
<span id="http-cache-introduction"></span><span id="index-4"></span><h2>Introducción a la memoria caché HTTP<a class="headerlink" href="#introduccion-a-la-memoria-cache-http" title="Permalink to this headline">¶</a></h2>
<p>Para aprovechar las ventajas de las capas de memoria caché disponibles, tu aplicación se debe poder comunicar con las respuestas que son memorizables y las reglas que rigen cuándo y cómo la caché será obsoleta. Esto se hace ajustando las cabeceras de caché HTTP en la respuesta.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Ten en cuenta que &#8220;HTTP&#8221; no es más que el lenguaje (un lenguaje de texto simple) que los clientes web (navegadores, por ejemplo) y los servidores web utilizan para comunicarse entre sí. Cuando hablamos de la memoria caché HTTP, estamos hablando de la parte de ese lenguaje que permite a los clientes y servidores intercambiar información relacionada con la memoria caché.</p>
</div>
<p>HTTP especifica cuatro cabeceras de memoria caché de la respuesta en que estamos interesados:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Cache-Control</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Expires</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ETag</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Last-Modified</span></tt></li>
</ul>
<p>La cabecera más importante y versátil es la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>, la cual en realidad es una colección de variada información de la caché.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cada una de las cabeceras se explica en detalle en la sección <a class="reference internal" href="#http-expiration-validation"><em>Caducidad y validación HTTP</em></a>.</p>
</div>
<div class="section" id="la-cabecera-cache-control">
<span id="index-5"></span><h3>La cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt><a class="headerlink" href="#la-cabecera-cache-control" title="Permalink to this headline">¶</a></h3>
<p>La cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> es la única que no contiene una, sino varias piezas de información sobre la memoria caché de una respuesta. Cada pieza de información está separada por una coma:</p>
<div class="highlight-python"><pre>Cache-Control: private, max-age=0, must-revalidate

Cache-Control: max-age=3600, must-revalidate</pre>
</div>
<p>Symfony proporciona una abstracción de la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> para hacer más manejable su creación:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">$respuesta = new Response();</span>

<span class="x">// marca la respuesta como publica o privada</span>
<span class="x">$respuesta-&gt;setPublic();</span>
<span class="x">$respuesta-&gt;setPrivate();</span>

<span class="x">// fija la edad máxima de privado o compartido</span>
<span class="x">$respuesta-&gt;setMaxAge(600);</span>
<span class="x">$respuesta-&gt;setSharedMaxAge(600);</span>

<span class="x">// fija una directiva personalizada Cache-Control</span>
<span class="x">$respuesta-&gt;headers-&gt;addCacheControlDirective(&#39;must-revalidate&#39;, true);</span>
</pre></div>
</div>
</div>
<div class="section" id="respuestas-publicas-frente-a-privadas">
<h3>Respuestas públicas frente a privadas<a class="headerlink" href="#respuestas-publicas-frente-a-privadas" title="Permalink to this headline">¶</a></h3>
<p>Ambas, la pasarela de caché y la caché sustituta, son consideradas como cachés &#8220;compartidas&#8221; debido a que el contenido memorizado en caché es compartido por más de un usuario. Si cada vez equivocadamente una memoria caché compartida almacena una respuesta específica al usuario, posteriormente la puede devolver a cualquier cantidad de usuarios diferentes. ¡Imagina si la información de tu cuenta se memoriza en caché y luego la regresa a todos los usuarios posteriores que soliciten la página de su cuenta!</p>
<p>Para manejar esta situación, cada respuesta se puede fijar para que sea pública o privada:</p>
<ul class="simple">
<li><em>public</em>: Indica que la respuesta se puede memorizar en caché por ambas cachés privadas y compartidas;</li>
<li><em>private</em>: Indica que la totalidad o parte del mensaje de la respuesta es para un solo usuario y no se debe tener en caché en una memoria caché compartida.</li>
</ul>
<p>Symfony por omisión conservadoramente fija cada respuesta para que sea privada. Para aprovechar las ventajas de cachés compartidas (como la sustituta inversa de Symfony2), la respuesta explícitamente se fijará como pública.</p>
</div>
<div class="section" id="metodos-seguros">
<span id="index-6"></span><h3>Métodos seguros<a class="headerlink" href="#metodos-seguros" title="Permalink to this headline">¶</a></h3>
<p>La memoria caché HTTP sólo funciona para métodos HTTP &#8220;seguros&#8221; (como GET y HEAD). Estar seguro significa que nunca cambia de estado la aplicación en el servidor al servir la petición (por supuesto puedes registrar información, datos de la caché, etc.)
Esto tiene dos consecuencias muy razonables:</p>
<ul class="simple">
<li><em>Nunca</em> debes cambiar el estado de tu aplicación al responder a una petición GET o HEAD. Incluso si no utilizas una pasarela caché, la presencia de la caché sustituta significa que alguna petición <tt class="docutils literal"><span class="pre">GET</span></tt> o <tt class="docutils literal"><span class="pre">HEAD</span></tt> puede o no llegar a tu servidor.</li>
<li>No esperas métodos PUT, POST o DELETE en caché. Estos métodos están diseñados para utilizarse al mutar el estado de tu aplicación (por ejemplo, borrar una entrada de blog). La memoria caché debe impedir que determinadas peticiones toquen y muten tu aplicación.</li>
</ul>
</div>
<div class="section" id="reglas-de-cache-y-valores-predeterminados">
<h3>Reglas de caché y valores predeterminados<a class="headerlink" href="#reglas-de-cache-y-valores-predeterminados" title="Permalink to this headline">¶</a></h3>
<p>HTTP 1.1 por omisión, permite a cualquiera memorizar en caché a menos que haya una cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> explícita. En la práctica, la mayoría de cachés no hacen nada cuando solicitan una galleta, una cabecera de autorización, utilizar un método no seguro (es decir, PUT, POST, DELETE), o cuando las respuestas tienen código de redirección de estado.</p>
<p>Symfony2 automáticamente establece una sensible y conservadora cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> cuando esta no está definida por el desarrollador, siguiendo estas reglas:</p>
<ul class="simple">
<li>Si no haz definido cabecera caché (<tt class="docutils literal"><span class="pre">Cache-Control</span></tt>, <tt class="docutils literal"><span class="pre">Expires</span></tt>,  <tt class="docutils literal"><span class="pre">ETag</span></tt> o <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>), <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> es establecida en <tt class="docutils literal"><span class="pre">no-cache</span></tt>, lo cual significa que la respuesta no se memoriza en caché;</li>
<li>Si <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> está vacía (pero una de las otras cabeceras de caché está presente), su valor se establece en <tt class="docutils literal"><span class="pre">private,</span> <span class="pre">must-revalidate</span></tt>;</li>
<li>Pero si por lo menos una  directiva <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> está establecida, y no se han añadido directivas <tt class="docutils literal"><span class="pre">public</span></tt> o <tt class="docutils literal"><span class="pre">private</span></tt> de forma explícita, Symfony2 agrega la directiva <tt class="docutils literal"><span class="pre">private</span></tt> automáticamente (excepto cuando <tt class="docutils literal"><span class="pre">s-maxage</span></tt> está establecida).</li>
</ul>
</div>
</div>
<div class="section" id="caducidad-y-validacion-http">
<span id="http-expiration-validation"></span><h2>Caducidad y validación HTTP<a class="headerlink" href="#caducidad-y-validacion-http" title="Permalink to this headline">¶</a></h2>
<p>La especificación HTTP define dos modelos de memoria caché:</p>
<ul class="simple">
<li>Con el <a class="reference external" href="http://tools.ietf.org/html/rfc2616#section-13.2">modelo de caducidad</a>, sólo tienes que especificar el tiempo en que la respuesta se debe considerar &#8220;fresca&#8221; incluyendo una cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> y/o una <tt class="docutils literal"><span class="pre">Expires</span></tt>. Las cachés que entienden de expiración no harán la misma petición hasta que la versión en caché llegue a su fecha de caducidad y se convierta en &#8220;obsoleta&#8221;.</li>
<li>Cuando las páginas realmente son muy dinámicas (es decir, su representación cambia frecuentemente), a menudo es necesario el <a class="reference external" href="http://tools.ietf.org/html/rfc2616#section-13.3">modelo de validación</a>. Con este modelo, la memoria caché memoriza la respuesta, pero, pregunta al servidor en cada petición si la respuesta memorizada sigue siendo válida. La aplicación utiliza un identificador de respuesta único (la cabecera <tt class="docutils literal"><span class="pre">Etag</span></tt>) y/o una marca de tiempo (la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>) para comprobar si la página ha cambiado desde su caché.</li>
</ul>
<p>El objetivo de ambos modelos es nunca generar la misma respuesta en dos ocasiones dependiendo de una caché para almacenar y devolver respuestas &#8220;fresco&#8221;.</p>
<div class="sidebar">
<p class="first sidebar-title">Leyendo la especificación HTTP</p>
<p>La especificación HTTP define un lenguaje sencillo pero potente en el cual clientes y servidores se pueden comunicar. Como desarrollador web, el modelo petición-respuesta de la especificación domina nuestro trabajo. Lamentablemente, el documento de la especificación real - <a class="reference external" href="http://tools.ietf.org/html/rfc2616">RFC 2616</a> - puede ser difícil de leer.</p>
<p>Hay un esfuerzo en curso (<a class="reference external" href="http://tools.ietf.org/wg/httpbis/">HTTP Bis</a>) para reescribir la RFC 2616. Este no describe una nueva versión de HTTP, sino sobre todo aclara la especificación HTTP original. También mejora la organización de la especificación dividiéndola en siete partes, todo lo relacionado con la memoria caché HTTP se puede encontrar en dos partes dedicadas (<a class="reference external" href="http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-12">P4 - Petición condicional</a> y <a class="reference external" href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-12">P6 - En caché: Exploración y caché intermediaria</a>).</p>
<p class="last">Como desarrollador web, te invitamos a leer la especificación. Su claridad y poder - incluso más de diez años después de su creación - tiene un valor incalculable. No te desanimes por la apariencia de la especificación - su contenido es mucho más bello que la cubierta.</p>
</div>
<div class="section" id="caducidad">
<span id="index-7"></span><h3>Caducidad<a class="headerlink" href="#caducidad" title="Permalink to this headline">¶</a></h3>
<p>El modelo de caducidad es el más eficiente y simple de los dos modelos de memoria caché y se debe utilizar siempre que sea posible. Cuando una respuesta se memoriza en caché con una caducidad, la caché memorizará la respuesta y la enviará directamente sin tocar a la aplicación hasta que esta caduque.</p>
<p>El modelo de caducidad se puede lograr usando una de dos, casi idénticas, cabeceras HTTP: <tt class="docutils literal"><span class="pre">Expires</span></tt> o <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>.</p>
</div>
<div class="section" id="caducidad-con-la-cabecera-expires">
<span id="index-8"></span><h3>Caducidad con la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt><a class="headerlink" href="#caducidad-con-la-cabecera-expires" title="Permalink to this headline">¶</a></h3>
<p>De acuerdo con la especificación HTTP &#8220;el campo de la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt> da la fecha/hora después de la cual se considera la respuesta es vieja&#8221;. La cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt> se puede establecer con el método <tt class="docutils literal"><span class="pre">setExpires()</span></tt> de <tt class="docutils literal"><span class="pre">Respuesta</span></tt>. Esta necesita una instancia de <tt class="docutils literal"><span class="pre">DateTime</span></tt> como argumento:</p>
<div class="highlight-python"><pre>$date = new DateTime();
$date-&gt;modify('+600 seconds');

$respuesta-&gt;setExpires($date);</pre>
</div>
<p>El resultado de la cabecera HTTP se verá así:</p>
<div class="highlight-python"><pre>Expires: Thu, 01 Mar 2011 16:00:00 GMT</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">El método <tt class="docutils literal"><span class="pre">setExpires()</span></tt> automáticamente convierte la fecha a la zona horaria GMT como lo requiere la especificación.</p>
</div>
<p>La cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt> adolece de dos limitaciones. En primer lugar, los relojes en el servidor Web y la caché (por ejemplo el navegador) deben estar sincronizados. Luego, la especificación establece que &#8220;los servidores HTTP/1.1 no deben enviar a <tt class="docutils literal"><span class="pre">Expires</span></tt> fechas de más de un año en el futuro&#8221;.</p>
</div>
<div class="section" id="caducidad-con-la-cabecera-cache-control">
<span id="index-9"></span><h3>Caducidad con la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt><a class="headerlink" href="#caducidad-con-la-cabecera-cache-control" title="Permalink to this headline">¶</a></h3>
<p>Debido a las limitaciones de la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt>, la mayor parte del tiempo, debes usar la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> en su lugar. Recordemos que la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> se utiliza para especificar muchas directivas de caché diferentes. Para caducidad, hay dos directivas, <tt class="docutils literal"><span class="pre">max-age</span></tt> y <tt class="docutils literal"><span class="pre">s-maxage</span></tt>. La primera la utilizan todas las cachés, mientras que la segunda sólo se tiene en cuenta por las cachés compartidas:</p>
<div class="highlight-python"><pre>// Establece el número de segundos después de que la
// respuesta ya no se debe considerar fresca
$respuesta-&gt;setMaxAge(600);

// Lo mismo que la anterior pero sólo para cachés compartidas
$respuesta-&gt;setSharedMaxAge(600);</pre>
</div>
<p>La cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> debería tener el siguiente formato (el cual puede tener directivas adicionales):</p>
<div class="highlight-python"><pre>Cache-Control: max-age=600, s-maxage=600</pre>
</div>
</div>
<div class="section" id="validando">
<span id="index-10"></span><h3>Validando<a class="headerlink" href="#validando" title="Permalink to this headline">¶</a></h3>
<p>Cuando un recurso se tiene que actualizar tan pronto como se realiza un cambio en los datos subyacentes, el modelo de caducidad se queda corto. Con el modelo de caducidad, no se pedirá a la aplicación que devuelva la respuesta actualizada hasta que la caché finalmente se convierta en obsoleta.</p>
<p>El modelo de validación soluciona este problema. Bajo este modelo, la memoria caché sigue almacenando las respuestas. La diferencia es que, por cada petición, la caché pregunta a la aplicación cuando o no la respuesta memorizada sigue siendo válida. Si la caché todavía <em>es</em> válida, tu aplicación debe devolver un código de estado 304 y no el contenido. Esto le dice a la caché que está bien devolver la respuesta memorizada.</p>
<p>Bajo este modelo, sobre todo ahorras ancho de banda ya que la representación no se envía dos veces al mismo cliente (en su lugar se envía una respuesta 304). Pero si diseñas cuidadosamente tu aplicación, es posible que puedas obtener los datos mínimos necesarios para enviar una respuesta 304 y ahorrar CPU también (más abajo puedes ver una implementación de ejemplo).</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">El código de estado 304 significa &#8220;No Modificado&#8221;. Es importante porque este código de estado <em>no</em> tiene el contenido real solicitado.
En cambio, la respuesta simplemente es un ligero conjunto de instrucciones que indican a la caché que se debe utilizar la versión almacenada.</p>
</div>
<p>Al igual que con la caducidad, hay dos cabeceras HTTP diferentes que se pueden utilizar para implementar el modelo de validación: <tt class="docutils literal"><span class="pre">Etag</span></tt> y <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>.</p>
</div>
<div class="section" id="validacion-con-la-cabecera-etag">
<span id="index-11"></span><h3>Validación con la cabecera <tt class="docutils literal"><span class="pre">ETag</span></tt><a class="headerlink" href="#validacion-con-la-cabecera-etag" title="Permalink to this headline">¶</a></h3>
<p>La cabecera <tt class="docutils literal"><span class="pre">ETag</span></tt> es una cabecera de cadena (llamada &#8220;entidad-etiqueta&#8221;) que identifica unívocamente una representación del recurso destino. Este es generado completamente y establecido por tu aplicación de modo que puedes decir, por ejemplo, si el recurso memorizado <tt class="docutils literal"><span class="pre">/sobre</span></tt> está al día con el que tu aplicación iba a devolver. Una <tt class="docutils literal"><span class="pre">ETag</span></tt> es como una huella digital y se utiliza para comparar rápidamente si dos versiones diferentes de un recurso son equivalentes. Como las huellas digitales, cada <tt class="docutils literal"><span class="pre">ETag</span></tt> debe ser única en todas las representaciones de un mismo recurso.</p>
<p>Vamos a caminar a través de una aplicación sencilla que genera el ETag como el md5 del contenido:</p>
<div class="highlight-python"><pre>public function indexAction()
{
    $respuesta = $this-&gt;render('MiPaquete:Main:index.html.twig');
    $respuesta-&gt;setETag(md5($respuesta-&gt;getContent()));
    $respuesta-&gt;isNotModified($this-&gt;getRequest());

    return $respuesta;
}</pre>
</div>
<p>El método <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> compara la <tt class="docutils literal"><span class="pre">ETag</span></tt> enviada en la <tt class="docutils literal"><span class="pre">Petición</span></tt> con la enviada en la <tt class="docutils literal"><span class="pre">Respuesta</span></tt>. Si ambas coinciden, el método establece automáticamente el código de estado de la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> a 304.</p>
<p>Este algoritmo es bastante simple y muy genérico, pero es necesario crear la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> completa antes de ser capaz de calcular el ETag, lo cual es subóptimo.
En otras palabras, esta ahorra ancho de banda, pero no ciclos de CPU.</p>
<p>En la sección <a class="reference internal" href="#optimizing-cache-validation"><em>Optimizando tu código con validación</em></a>, vamos a mostrar cómo puedes utilizar la validación de manera más inteligente para determinar la validez de una caché sin hacer tanto trabajo.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Symfony2 también apoya ETags débiles pasando <tt class="docutils literal"><span class="pre">true</span></tt> como segundo argumento del método <a href="#id1"><span class="problematic" id="id2">:method:`Symfony\\Component\\HttpFoundation\\Response::setETag`</span></a>.</p>
</div>
</div>
<div class="section" id="validacion-con-la-cabecera-last-modified">
<span id="index-12"></span><h3>Validación con la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt><a class="headerlink" href="#validacion-con-la-cabecera-last-modified" title="Permalink to this headline">¶</a></h3>
<p>La cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> es la segunda forma de validación. De acuerdo con la especificación HTTP, &#8220;El campo de la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> indica la fecha y hora en que el servidor origen considera que la representación fue modificada por última vez&#8221;. En otras palabras, la aplicación decide si o no el contenido memorizado se ha actualizado en función de si es o no ha sido actualizado desde que la respuesta entró en caché.</p>
<p>Por ejemplo, puedes utilizar la última fecha de actualización de todos los objetos necesarios para calcular la representación del recurso como valor para el valor de la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>:</p>
<div class="highlight-python"><pre>public function showAction($articleSlug)
{
    // ...

    $articuloFecha = new \DateTime($articulo-&gt;getUpdatedAt());
    $autorFecha = new \DateTime($autor-&gt;getUpdatedAt());

    $date = $autorFecha &gt; $articuloFecha ? $autorFecha : $articuloFecha;

    $respuesta-&gt;setLastModified($fecha);
    $respuesta-&gt;isNotModified($this-&gt;getRequest());

    return $respuesta;
}</pre>
</div>
<p>El método <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> compara la cabecera <tt class="docutils literal"><span class="pre">If-Modified-Since</span></tt> enviada por la petición con la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> situada en la respuesta. Si son equivalentes, la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> establecerá un código de estado 304.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">La cabecera <tt class="docutils literal"><span class="pre">If-Modified-Since</span></tt> de la petición es igual a la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> de la última respuesta enviada al cliente por ese recurso en particular.
Así es como se comunican el cliente y el servidor entre ellos y deciden si el recurso se ha actualizado desde que se memorizó.</p>
</div>
</div>
<div class="section" id="optimizando-tu-codigo-con-validacion">
<span id="optimizing-cache-validation"></span><span id="index-13"></span><h3>Optimizando tu código con validación<a class="headerlink" href="#optimizando-tu-codigo-con-validacion" title="Permalink to this headline">¶</a></h3>
<p>El objetivo principal de cualquier estrategia de memoria caché es aligerar la carga de la aplicación.
Dicho de otra manera, cuanto menos hagas en tu aplicación para devolver una respuesta 304, mejor. El método <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> hace exactamente eso al exponer un patrón simple y eficiente:</p>
<div class="highlight-python"><pre>public function showAction($articleSlug)
{
    // Obtiene la mínima información para calcular la ETag
    // o el valor de Last-Modified (basado en la petición,
    // los datos se recuperan de una base de datos o un par
    // clave-valor guardado, por ejemplo)
    $articulo = // ...

    // crea una respuesta con una ETag y/o una cabecera Last-Modified
    $respuesta = new Response();
    $respuesta-&gt;setETag($articulo-&gt;computeETag());
    $respuesta-&gt;setLastModified($articulo-&gt;getPublishedAt());

    // verifica que la respuesta no sea modificada por la petición dada
    if ($respuesta-&gt;isNotModified($this-&gt;getRequest())) {
        // devuelve inmediatamente la Respuesta 304
        return $respuesta;
    } else {
        // aquí hace más trabajo - como recuperar más datos
        $comentarios = // ...

        // o reproduce una plantilla con la $respuesta que ya hemos iniciado
        return $this-&gt;render(
            'MiPaquete:MiController:articulo.html.twig',
            array('articulo' =&gt; $articulo, 'comentarios' =&gt; $comentarios),
            $respuesta
        );
    }
}</pre>
</div>
<p>Cuando la <tt class="docutils literal"><span class="pre">Respuesta</span></tt> no es modificada, el <tt class="docutils literal"><span class="pre">isNotModified()</span></tt> automáticamente fija el código de estado de la respuesta a <tt class="docutils literal"><span class="pre">304</span></tt>, remueve el contenido, y remueve algunas cabeceras que no deben estar presentes en respuestas <tt class="docutils literal"><span class="pre">304</span></tt> (consulta
<a href="#id3"><span class="problematic" id="id4">:method:`Symfony\\Component\\HttpFoundation\\Response::setNotModified`</span></a>).</p>
</div>
<div class="section" id="variando-la-respuesta">
<span id="index-14"></span><h3>Variando la respuesta<a class="headerlink" href="#variando-la-respuesta" title="Permalink to this headline">¶</a></h3>
<p>Hasta ahora, hemos supuesto que cada URI tiene exactamente una representación del recurso destino. De forma predeterminada, la memoria caché HTTP se realiza mediante la URI del recurso como la clave de caché. Si dos personas solicitan la misma URI de un recurso memorizable, la segunda persona recibirá la versión en caché.</p>
<p>A veces esto no es suficiente y diferentes versiones de la misma URI necesitan memorizarse en caché basándose en uno o más valores de las cabeceras de la petición. Por ejemplo, si comprimes las páginas cuando el cliente lo permite, cualquier URI tiene dos representaciones: una cuando el cliente es compatible con la compresión, y otra cuando no. Esta determinación se hace por el valor de la cabecera <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> de la petición.</p>
<p>En este caso, necesitamos que la memoria almacene una versión comprimida y otra sin comprimir de la respuesta para la URI particular y devolverlas basándose en el valor de la cabecera <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt>. Esto se hace usando la cabecera <tt class="docutils literal"><span class="pre">Vary</span></tt> de la respuesta, la cual es una lista separada por comas de diferentes cabeceras cuyos valores lanzan una representación diferente de los recursos solicitados:</p>
<div class="highlight-python"><pre>Vary: Accept-Encoding, User-Agent</pre>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Esta cabecera <tt class="docutils literal"><span class="pre">Vary</span></tt> particular debería memorizar diferentes versiones de cada recurso en base a la URI y el valor de las cabeceras <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> y <tt class="docutils literal"><span class="pre">User-Agent</span></tt> de la petición.</p>
</div>
<p>El objeto <tt class="docutils literal"><span class="pre">Respuesta</span></tt> ofrece una interfaz limpia para gestionar la cabecera <tt class="docutils literal"><span class="pre">Vary</span></tt>:</p>
<div class="highlight-python"><pre>// establece una cabecera vary
$respuesta-&gt;setVary('Accept-Encoding');

// establece múltiples cabeceras vary
$respuesta-&gt;setVary(array('Accept-Encoding', 'User-Agent'));</pre>
</div>
<p>El método <tt class="docutils literal"><span class="pre">setVary()</span></tt> toma un nombre de cabecera o un arreglo de nombres de cabecera de cual respuesta varía.</p>
</div>
<div class="section" id="caducidad-y-validacion">
<h3>Caducidad y validación<a class="headerlink" href="#caducidad-y-validacion" title="Permalink to this headline">¶</a></h3>
<p>Por supuesto, puedes utilizar tanto la caducidad como la validación de la misma <tt class="docutils literal"><span class="pre">Respuesta</span></tt>.
La caducidad gana a la validación, te puedes beneficiar de lo mejor de ambos mundos. En otras palabras, utilizando tanto la caducidad como la validación, puedes instruir a la caché para que sirva el contenido memorizado, mientras que revisas de nuevo algún intervalo (de  caducidad) para verificar que el contenido sigue siendo válido.</p>
</div>
<div class="section" id="mas-metodos-de-respuesta">
<span id="index-15"></span><h3>Más métodos de respuesta<a class="headerlink" href="#mas-metodos-de-respuesta" title="Permalink to this headline">¶</a></h3>
<p>La clase Respuesta proporciona muchos métodos más relacionados con la caché. Estos son los más útiles:</p>
<div class="highlight-python"><pre>// Marca la respuesta como obsoleta
$respuesta-&gt;expire();

// Fuerza a la respuesta a devolver una adecuada respuesta 304 sin contenido
$respuesta-&gt;setNotModified();</pre>
</div>
<p>Además, puedes confugurar muchas de las cabeceras HTTP relacionadas con la caché a través del método <tt class="docutils literal"><span class="pre">setCache()</span></tt>:</p>
<div class="highlight-python"><pre>// Establece la configuración de caché en una llamada
$respuesta-&gt;setCache(array(
    'etag'          =&gt; $etag,
    'last_modified' =&gt; $date,
    'max_age'       =&gt; 10,
    's_maxage'      =&gt; 10,
    'public'        =&gt; true,
    // 'private'    =&gt; true,
));</pre>
</div>
</div>
</div>
<div class="section" id="usando-inclusion-del-borde-lateral">
<span id="edge-side-includes"></span><span id="index-16"></span><h2>Usando inclusión del borde lateral<a class="headerlink" href="#usando-inclusion-del-borde-lateral" title="Permalink to this headline">¶</a></h2>
<p>Las pasarelas de caché son una excelente forma de hacer que tu sitio web tenga un mejor desempeño. Pero tienen una limitación: sólo podrán memorizar páginas enteras. Si no puedes memorizar todas las páginas o si partes de una página tienen &#8220;más&#8221; elementos dinámicos, se te acabó la suerte. Afortunadamente, Symfony2 ofrece una solución para estos casos, basada ​​en una tecnología llamada <a class="reference external" href="http://www.w3.org/TR/esi-lang">ESI</a>, o Inclusión de bordes laterales (Edge Side Includes). Akamaï escribió esta especificación hace casi 10 años, y esta permite que partes específicas de una página tengan una estrategia de memorización diferente a la de la página principal.</p>
<p>La especificación <a href="#id9"><span class="problematic" id="id10">|ESI|</span></a> describe las etiquetas que puedes incrustar en tus páginas para comunicarte con la pasarela de caché. Symfony2 sólo implementa una etiqueta, <tt class="docutils literal"><span class="pre">include</span></tt>, ya que es la única útil fuera del contexto de Akamaï:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;body&gt;</span>
        Algún contenido

        <span class="c">&lt;!-- aquí integra el contenido de otra página --&gt;</span>
        <span class="nt">&lt;esi:include</span> <span class="na">src=</span><span class="s">&quot;http://...&quot;</span> <span class="nt">/&gt;</span>

        Más contenido
    <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Observa que en el ejemplo cada etiqueta <a href="#id11"><span class="problematic" id="id12">|ESI|</span></a> tiene una URL completamente cualificada.
Una etiqueta <a href="#id13"><span class="problematic" id="id14">|ESI|</span></a> representa un fragmento de página que se puede recuperar a través de la URL.</p>
</div>
<p>Cuando se maneja una petición, la pasarela de caché obtiene toda la página de su caché o la pide a partir de la interfaz de administración de tu aplicación. Si la respuesta contiene una o más etiquetas <a href="#id15"><span class="problematic" id="id16">|ESI|</span></a>, estas se procesan de la misma manera. En otras palabras, la pasarela caché o bien, recupera el fragmento de página incluida en su caché o de nuevo pide el fragmento de página desde la interfaz de administración de tu aplicación. Cuando se han resuelto todas las etiquetas <a href="#id17"><span class="problematic" id="id18">|ESI|</span></a>, la pasarela caché une cada una en la página principal y envía el contenido final al cliente.</p>
<p>Todo esto sucede de forma transparente a nivel de la pasarela caché (es decir, fuera de tu aplicación). Como verás, si decides tomar ventaja de las etiquetas <a href="#id19"><span class="problematic" id="id20">|ESI|</span></a>, Symfony2 hace que el proceso de incluirlas sea casi sin esfuerzo.</p>
<div class="section" id="usando-esi-en-symfony2">
<h3>Usando <a href="#id21"><span class="problematic" id="id22">|ESI|</span></a> en Symfony2<a class="headerlink" href="#usando-esi-en-symfony2" title="Permalink to this headline">¶</a></h3>
<p>Primero, para usar <a href="#id23"><span class="problematic" id="id24">|ESI|</span></a>, asegúrate de activarlo en la configuración de tu aplicación:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">framework</span><span class="p-Indicator">:</span>
    <span class="c1"># ...</span>
    <span class="l-Scalar-Plain">esi</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">enabled</span><span class="p-Indicator">:</span> <span class="nv">true</span> <span class="p-Indicator">}</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><pre>&lt;!-- app/config/config.xml --&gt;
&lt;framework:config ...&gt;
    &lt;!-- ... --&gt;
    &lt;framework:esi enabled="true" /&gt;
&lt;/framework:config&gt;</pre>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// app/config/config.php</span>
<span class="x">$contenedor-&gt;loadFromExtension(&#39;framework&#39;, array(</span>
<span class="x">    // ...</span>
<span class="x">    &#39;esi&#39;    =&gt; array(&#39;enabled&#39; =&gt; true),</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Ahora, supongamos que tenemos una página que es relativamente estable, a excepción de un teletipo de noticias en la parte inferior del contenido. Con <a href="#id25"><span class="problematic" id="id26">|ESI|</span></a>, podemos memorizar el teletipo de noticias independiente del resto de la página.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">public function indexAction()</span>
<span class="x">{</span>
<span class="x">    $respuesta = $this-&gt;render(&#39;MiPaquete:MiController:index.html.twig&#39;);</span>
<span class="x">    $respuesta-&gt;setSharedMaxAge(600);</span>

<span class="x">    return $respuesta;</span>
<span class="x">}</span>
</pre></div>
</div>
<p>En este ejemplo, hemos dado al caché de la página completa un tiempo de vida de diez minutos.
En seguida, vamos a incluir el teletipo de noticias en la plantilla incorporando una acción.
Esto se hace a través del ayudante <tt class="docutils literal"><span class="pre">render</span></tt> (consulta la sección <a class="reference internal" href="templating.html#templating-embedding-controller"><em>Incrustando controladores</em></a> para más detalles).</p>
<p>Como el contenido integrado viene de otra página (o controlador en este caso), Symfony2 utiliza el ayudante <tt class="docutils literal"><span class="pre">render</span></tt> estándar para configurar las etiquetas <a href="#id27"><span class="problematic" id="id28">|ESI|</span></a>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">render</span> <span class="s1">&#39;...:noticias&#39;</span> <span class="k">with</span> <span class="o">{},</span> <span class="o">{</span><span class="s1">&#39;standalone&#39;</span><span class="o">:</span> <span class="kp">true</span><span class="o">}</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;actions&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;...:noticias&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;standalone&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">))</span> <span class="cp">?&gt;</span><span class="x"></span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Al establecer <tt class="docutils literal"><span class="pre">standalone</span></tt> a <tt class="docutils literal"><span class="pre">true</span></tt>, le dices a Symfony2 que la acción se debe reproducir como una etiqueta <a href="#id29"><span class="problematic" id="id30">|ESI|</span></a>. Tal vez te preguntes por qué querría usar un ayudante en vez de escribir la etiqueta <a href="#id31"><span class="problematic" id="id32">|ESI|</span></a> en si misma. Eso es porque usar un ayudante hace que tu aplicación trabaje, incluso si no hay pasarela caché instalada. Vamos a ver cómo funciona.</p>
<p>Cuando <tt class="docutils literal"><span class="pre">standalone</span></tt> es <tt class="docutils literal"><span class="pre">false</span></tt> (predeterminado), Symfony2 combina el contenido de la página incluida en la principal antes de enviar la respuesta al cliente. Pero cuando <tt class="docutils literal"><span class="pre">standalone</span></tt> es <tt class="docutils literal"><span class="pre">true</span></tt>, <em>y</em> si Symfony2 detecta que está hablando con una pasarela caché compatible con <a href="#id33"><span class="problematic" id="id34">|ESI|</span></a>, genera una etiqueta <tt class="docutils literal"><span class="pre">include</span></tt> <a href="#id35"><span class="problematic" id="id36">|ESI|</span></a>. Pero si no hay una pasarela caché o si no es compatible con <a href="#id37"><span class="problematic" id="id38">|ESI|</span></a>, Symfony2 termina fusionando el contenido de las páginas incluidas en la principal como lo habría hecho si <tt class="docutils literal"><span class="pre">standalone</span></tt> se hubiera establecido en <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Symfony2 detecta si una pasarela caché admite <a href="#id39"><span class="problematic" id="id40">|ESI|</span></a> a través de otra especificación Akamaï que fuera de la caja es compatible con el sustituto inverso de Symfony2.</p>
</div>
<p>La acción integrada ahora puede especificar sus propias reglas de caché, totalmente independientes de la página principal.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">public function noticiasAction()</span>
<span class="x">{</span>
<span class="x">  // ...</span>

<span class="x">  $respuesta-&gt;setSharedMaxAge(60);</span>
<span class="x">}</span>
</pre></div>
</div>
<p>Con <a href="#id41"><span class="problematic" id="id42">|ESI|</span></a>, la caché de la página completa será válida durante 600 segundos, pero la caché del componente de noticias sólo dura 60 segundos.</p>
<p>Un requisito de <a href="#id43"><span class="problematic" id="id44">|ESI|</span></a>, sin embargo, es que la acción incrustada sea accesible a través de una URL para que la pasarela caché se pueda buscar independientemente del resto de la página. Por supuesto, una acción no se puede acceder a través de una URL a menos que haya una ruta que apunte a la misma. Symfony2 se encarga de esto a través de una ruta genérica y un controlador. Para que la etiqueta <a href="#id45"><span class="problematic" id="id46">|ESI|</span></a> <tt class="docutils literal"><span class="pre">include</span></tt> funcione correctamente, debes definir la ruta <tt class="docutils literal"><span class="pre">_internal</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/routing.yml</span>
<span class="l-Scalar-Plain">_internal</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">resource</span><span class="p-Indicator">:</span> <span class="s">&quot;@FrameworkBundle/Resources/config/routing/internal.xml&quot;</span>
    <span class="l-Scalar-Plain">prefix</span><span class="p-Indicator">:</span>   <span class="l-Scalar-Plain">/_internal</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/routing.xml --&gt;</span>
<span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>

<span class="nt">&lt;routes</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/routing&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&quot;@FrameworkBundle/Resources/config/routing/internal.xml&quot;</span> <span class="na">prefix=</span><span class="s">&quot;/_internal&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/routes&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// app/config/routing.php</span>
<span class="x">use Symfony\Component\Routing\RouteCollection;</span>
<span class="x">use Symfony\Component\Routing\Route;</span>

<span class="x">$coleccion-&gt;addCollection($loader-&gt;import(&#39;@FrameworkBundle/Resources/config/routing/internal.xml&#39;, &#39;/_internal&#39;));</span>

<span class="x">return $coleccion;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Puesto que esta ruta permite que todas las acciones se accedan a través de una URL, posiblemente desees protegerla usando el cortafuegos de Symfony2 (permitiendo acceder al rango IP del sustituto inverso).</p>
</div>
<p>Una gran ventaja de esta estrategia de memoria caché es que puedes hacer tu aplicación tan dinámica como sea necesario y al mismo tiempo, tocar la aplicación lo menos posible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Una vez que comiences a usar <a href="#id47"><span class="problematic" id="id48">|ESI|</span></a>, recuerda usar siempre la directiva <tt class="docutils literal"><span class="pre">s-maxage</span></tt> en lugar de <tt class="docutils literal"><span class="pre">max-age</span></tt>. Como el navegador nunca recibe recursos agregados, no es consciente del subcomponente, y por lo tanto obedecerá la directiva <tt class="docutils literal"><span class="pre">max-age</span></tt> y memorizará la página completa. Y no quieres eso.</p>
</div>
<p>El ayudante <tt class="docutils literal"><span class="pre">render</span></tt> es compatible con otras dos útiles opciones:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">alt</span></tt>: utilizada como el atributo <tt class="docutils literal"><span class="pre">alt</span></tt> en la etiqueta <a href="#id49"><span class="problematic" id="id50">|ESI|</span></a>, el cual te permite especificar una URL alternativa para utilizarla si no se puede encontrar <tt class="docutils literal"><span class="pre">src</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">ignore_errors</span></tt>: si se establece en <tt class="docutils literal"><span class="pre">true</span></tt>, se agrega un atributo <tt class="docutils literal"><span class="pre">onerror</span></tt> a la <a href="#id51"><span class="problematic" id="id52">|ESI|</span></a> con un valor de <tt class="docutils literal"><span class="pre">continue</span></tt> indicando que, en caso de una falla, la pasarela caché simplemente debe eliminar la etiqueta <a href="#id53"><span class="problematic" id="id54">|ESI|</span></a> silenciosamente.</li>
</ul>
</div>
</div>
<div class="section" id="invalidando-la-cache">
<span id="http-cache-invalidation"></span><span id="index-17"></span><h2>Invalidando la caché<a class="headerlink" href="#invalidando-la-cache" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>&#8220;Sólo hay dos cosas difíciles en Ciencias de la Computación. Invalidación de caché y nombrar cosas&#8221; &#8211;Phil Karlton</div></blockquote>
<p>Nunca debería ser necesario invalidar los datos memorizados en caché porque la invalidación ya se tiene en cuenta de forma nativa en los modelos de caché HTTP. Si utilizas la validación, por definición, no será necesario invalidar ninguna cosa, y si se utiliza la caducidad y necesitas invalidar un recurso, significa que estableciste la fecha de caducidad muy adelante en el futuro.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">También es porque no existe un mecanismo de invalidación que cualquier sustituto inverso pueda utilizar, sin cambiar nada en el código de tu aplicación.</p>
</div>
<p>En realidad, todos los sustitutos inversos proporcionan una manera de purgar datos almacenados en caché, pero la debes evitar tanto como sea posible. La forma más habitual es purgar la caché de una URL dada solicitándola con el método especial <tt class="docutils literal"><span class="pre">PURGE</span></tt> de HTTP.</p>
<p>Aquí está cómo puedes configurar la caché sustituta inversa de Symfony2 para apoyar al método <tt class="docutils literal"><span class="pre">PURGE</span></tt> de HTTP:</p>
<div class="highlight-python"><pre>// app/AppCache.php
class AppCache extends Cache
{
    protected function invalidate(Request $peticion)
    {
        if ('PURGE' !== $peticion-&gt;getMethod()) {
            return parent::invalidate($peticion);
        }

        $respuesta = new Response();
        if (!$this-&gt;store-&gt;purge($peticion-&gt;getUri())) {
            $respuesta-&gt;setStatusCode(404, 'Not purged');
        } else {
            $respuesta-&gt;setStatusCode(200, 'Purged');
        }

        return $respuesta;
    }
}</pre>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">De alguna manera, debes proteger el método <tt class="docutils literal"><span class="pre">PURGE</span></tt> HTTP para evitar que alguien aleatoriamente purgue los datos memorizados.</p>
</div>
</div>
<div class="section" id="resumen">
<h2>Resumen<a class="headerlink" href="#resumen" title="Permalink to this headline">¶</a></h2>
<p>Symfony2 fue diseñado para seguir las reglas probadas de la carretera: HTTP. El almacenamiento en caché no es una excepción. Dominar el sistema caché de Symfony2 significa familiarizarse con los modelos de caché HTTP y usarlos eficientemente. Esto significa que, en lugar de confiar sólo en la documentación de Symfony2 y ejemplos de código, tienes acceso a un mundo de conocimientos relacionados con la memorización en caché HTTP y la pasarela caché, tal como Varnish.</p>
</div>
<div class="section" id="aprende-mas-en-el-recetario">
<h2>Aprende más en el recetario<a class="headerlink" href="#aprende-mas-en-el-recetario" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="../cookbook/cache/varnish.html"><em>Cómo utilizar Varnish para acelerar mi sitio web</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Caché HTTP</a><ul>
<li><a class="reference internal" href="#la-memoria-cache-en-hombros-de-gigantes">La memoria caché en hombros de gigantes</a></li>
<li><a class="reference internal" href="#memoria-cache-con-pasarela-de-cache">Memoria caché con pasarela de caché</a><ul>
<li><a class="reference internal" href="#tipos-de-cache">Tipos de Caché</a></li>
<li><a class="reference internal" href="#sustituto-inverso-de-symfony2">Sustituto inverso de Symfony2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#introduccion-a-la-memoria-cache-http">Introducción a la memoria caché HTTP</a><ul>
<li><a class="reference internal" href="#la-cabecera-cache-control">La cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt></a></li>
<li><a class="reference internal" href="#respuestas-publicas-frente-a-privadas">Respuestas públicas frente a privadas</a></li>
<li><a class="reference internal" href="#metodos-seguros">Métodos seguros</a></li>
<li><a class="reference internal" href="#reglas-de-cache-y-valores-predeterminados">Reglas de caché y valores predeterminados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caducidad-y-validacion-http">Caducidad y validación HTTP</a><ul>
<li><a class="reference internal" href="#caducidad">Caducidad</a></li>
<li><a class="reference internal" href="#caducidad-con-la-cabecera-expires">Caducidad con la cabecera <tt class="docutils literal"><span class="pre">Expires</span></tt></a></li>
<li><a class="reference internal" href="#caducidad-con-la-cabecera-cache-control">Caducidad con la cabecera <tt class="docutils literal"><span class="pre">Cache-Control</span></tt></a></li>
<li><a class="reference internal" href="#validando">Validando</a></li>
<li><a class="reference internal" href="#validacion-con-la-cabecera-etag">Validación con la cabecera <tt class="docutils literal"><span class="pre">ETag</span></tt></a></li>
<li><a class="reference internal" href="#validacion-con-la-cabecera-last-modified">Validación con la cabecera <tt class="docutils literal"><span class="pre">Last-Modified</span></tt></a></li>
<li><a class="reference internal" href="#optimizando-tu-codigo-con-validacion">Optimizando tu código con validación</a></li>
<li><a class="reference internal" href="#variando-la-respuesta">Variando la respuesta</a></li>
<li><a class="reference internal" href="#caducidad-y-validacion">Caducidad y validación</a></li>
<li><a class="reference internal" href="#mas-metodos-de-respuesta">Más métodos de respuesta</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usando-inclusion-del-borde-lateral">Usando inclusión del borde lateral</a><ul>
<li><a class="reference internal" href="#usando-esi-en-symfony2">Usando |ESI| en Symfony2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invalidando-la-cache">Invalidando la caché</a></li>
<li><a class="reference internal" href="#resumen">Resumen</a></li>
<li><a class="reference internal" href="#aprende-mas-en-el-recetario">Aprende más en el recetario</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="security.html"
                        title="previous chapter">Seguridad</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="translation.html"
                        title="next chapter">Traduciendo</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/book/http_cache.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="translation.html" title="Traduciendo"
             >next</a> |</li>
        <li class="right" >
          <a href="security.html" title="Seguridad"
             >previous</a> |</li>
        <li><a href="../index.html">symfony-docs-es v1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Libro</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Osukaru.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>