

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Contenedor de servicios &mdash; symfony-docs-es v1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="symfony-docs-es v1 documentation" href="../index.html" />
    <link rel="up" title="Libro" href="index.html" />
    <link rel="next" title="Rendimiento" href="performance.html" />
    <link rel="prev" title="Traduciendo" href="translation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="performance.html" title="Rendimiento"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="translation.html" title="Traduciendo"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">symfony-docs-es v1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Libro</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="contenedor-de-servicios">
<span id="index-0"></span><h1>Contenedor de servicios<a class="headerlink" href="#contenedor-de-servicios" title="Permalink to this headline">¶</a></h1>
<p>Una moderna aplicación PHP está llena de objetos. Un objeto te puede facilitar la entrega de mensajes de correo electrónico, mientras que otro te puede permitir mantener información en una base de datos. En tu aplicación, puedes crear un objeto que gestiona tu inventario de productos, u otro objeto que procesa los datos de una API de terceros. El punto es que una aplicación moderna hace muchas cosas y está organizada en muchos objetos que se encargan de cada tarea.</p>
<p>En este capítulo, vamos a hablar de un objeto PHP especial en Symfony2 que te ayuda a crear una instancia, organizar y recuperar muchos objetos de tu aplicación.
Este objeto, llamado contenedor de servicios, te permitirá estandarizar y centralizar la forma en que se construyen los objetos en tu aplicación. El contenedor te facilita la vida, es superveloz, y enfatiza una arquitectura que promueve el código reutilizable y disociado. Y como todas las clases Symfony2 básicas usan el contenedor, aprenderás cómo ampliar, configurar y utilizar cualquier objeto en Symfony2. En gran parte, el contenedor de servicios es el mayor contribuyente a la velocidad y la extensibilidad de Symfony2.</p>
<p>Por último, configurar y usar el contenedor de servicios es fácil. Al final de este capítulo, te sentirás cómodo creando tus propios objetos y personalizando objetos de cualquier paquete de terceros a través del contenedor. Empezarás a escribir código más reutilizable, comprobable y disociado, simplemente porque el contenedor de servicios facilita la escritura de buen código.</p>
<div class="section" id="que-es-un-servicio">
<span id="index-1"></span><h2>¿Qué es un servicio?<a class="headerlink" href="#que-es-un-servicio" title="Permalink to this headline">¶</a></h2>
<p>En pocas palabras, un <a class="reference internal" href="../glossary.html#term-servicio"><em class="xref std std-term">Servicio</em></a> es cualquier objeto PHP que realiza algún tipo de tarea &#8220;global&#8221;. Es un nombre genérico que se utiliza a propósito en informática para describir un objeto creado para un propósito específico (por ejemplo, la entrega de mensajes de correo electrónico). Cada servicio se utiliza en toda tu aplicación cada vez que necesites la funcionalidad específica que proporciona. No tienes que hacer nada especial para hacer un servicio: simplemente escribe una clase PHP con algo de código que realiza una tarea específica. ¡Felicidades, acabas de crear un servicio!</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Por regla general, un objeto PHP es un servicio si se utiliza a nivel global en tu aplicación. Un solo servicio <tt class="docutils literal"><span class="pre">Mailer</span></tt> se utiliza a nivel global para enviar mensajes de correo electrónico mientras que muchos objetos <tt class="docutils literal"><span class="pre">Mensaje</span></tt> que entrega no son <em>servicios</em>. Del mismo modo, un objeto <tt class="docutils literal"><span class="pre">producto</span></tt> no es un servicio, sino un objeto <tt class="docutils literal"><span class="pre">producto</span></tt> que persiste objetos a una base de datos <em>es</em> un servicio.</p>
</div>
<p>Entonces, ¿cuál es la ventaja? La ventaja de pensar en &#8220;servicios&#8221; es que comienzas a pensar en la separación de cada parte de la funcionalidad de tu aplicación como una serie de servicios. Puesto que cada servicio se limita a un trabajo, puedes acceder fácilmente a cada servicio y usar su funcionalidad siempre que la necesites. Cada servicio también se puede probar y configurar más fácilmente, ya que está separado de la otra funcionalidad de tu aplicación. Esta idea se llama <a class="reference external" href="http://wikipedia.org/wiki/Service-oriented_architecture">arquitectura orientada a servicios</a> y no es única de Symfony2 e incluso de PHP. Estructurando tu aplicación en torno a un conjunto de clases Servicio independientes es una bien conocida y confiable práctica mejor orientada a objetos. Estas habilidades son clave para ser un buen desarrollador en casi cualquier lenguaje.</p>
</div>
<div class="section" id="que-es-un-contenedor-de-servicios">
<span id="index-2"></span><h2>¿Qué es un contenedor de servicios?<a class="headerlink" href="#que-es-un-contenedor-de-servicios" title="Permalink to this headline">¶</a></h2>
<p>Un  <a class="reference internal" href="../glossary.html#term-contenedor-de-servicios"><em class="xref std std-term">Contenedor de servicios</em></a> (o <em>contenedor de inyección de dependencias</em>) simplemente es un objeto PHP que gestiona la creación de instancias de servicios (es decir, objetos).
Por ejemplo, supongamos que tenemos una clase PHP simple que envía mensajes de correo electrónico.
Sin un contenedor de servicios, debemos crear manualmente el objeto cada vez que lo necesitemos:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">use Acme\HolaBundle\Mailer;</span>

<span class="x">$cartero = new Mailer(&#39;sendmail&#39;);</span>
<span class="x">$cartero-&gt;send(&#39;ryan@foobar.net&#39;, ... );</span>
</pre></div>
</div>
<p>Esto es bastante fácil. La clase imaginaria <tt class="docutils literal"><span class="pre">Mailer</span></tt> nos permite configurar el método utilizado para entregar los mensajes de correo electrónico (por ejemplo, <tt class="docutils literal"><span class="pre">sendmail</span></tt>, <tt class="docutils literal"><span class="pre">smtp</span></tt>, etc.)
¿Pero qué si queremos utilizar el servicio cliente de correo en algún otro lugar? Desde luego, no queremos repetir la configuración del gestor de correo <em>cada</em> vez que tenemos que utilizar el objeto <tt class="docutils literal"><span class="pre">Mailer</span></tt>. ¿Qué pasa si necesitamos cambiar el <tt class="docutils literal"><span class="pre">transporte</span></tt> de <tt class="docutils literal"><span class="pre">sendmail</span></tt> a <tt class="docutils literal"><span class="pre">smtp</span></tt> en todas partes en la aplicación? Necesitaríamos cazar todos los lugares que crean un servicio <tt class="docutils literal"><span class="pre">Mailer</span></tt> y modificarlo.</p>
</div>
<div class="section" id="creando-configurando-servicios-en-el-contenedor">
<span id="index-3"></span><h2>Creando/configurando servicios en el contenedor<a class="headerlink" href="#creando-configurando-servicios-en-el-contenedor" title="Permalink to this headline">¶</a></h2>
<p>Una mejor respuesta es dejar que el contenedor de servicios cree el objeto <tt class="docutils literal"><span class="pre">Mailer</span></tt> para ti. Para que esto funcione, debemos <em>enseñar</em> al contenedor cómo crear el servicio <tt class="docutils literal"><span class="pre">Mailer</span></tt>. Esto se hace a través de configuración, la cual se puede especificar en YAML, XML o PHP:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">services</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">mi_cartero</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">class</span><span class="p-Indicator">:</span>        <span class="l-Scalar-Plain">Acme\HolaBundle\Mailer</span>
        <span class="l-Scalar-Plain">arguments</span><span class="p-Indicator">:</span>    <span class="p-Indicator">[</span><span class="nv">sendmail</span><span class="p-Indicator">]</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/config.xml --&gt;</span>
<span class="nt">&lt;services&gt;</span>
    <span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;mi_cartero&quot;</span> <span class="na">class=</span><span class="s">&quot;Acme\HolaBundle\Mailer&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;argument&gt;</span>sendmail<span class="nt">&lt;/argument&gt;</span>
    <span class="nt">&lt;/service&gt;</span>
<span class="nt">&lt;/services&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// app/config/config.php</span>
<span class="x">use Symfony\Component\DependencyInjection\Definition;</span>

<span class="x">$contenedor-&gt;setDefinition(&#39;mi_cartero&#39;, new Definition(</span>
<span class="x">    &#39;Acme\HolaBundle\Mailer&#39;,</span>
<span class="x">    array(&#39;sendmail&#39;)</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cuando se inicia, por omisión Symfony2 construye el contenedor de servicios usando la configuración de (<tt class="docutils literal"><span class="pre">app/config/config.yml</span></tt>). El archivo exacto que se carga es dictado por el método <tt class="docutils literal"><span class="pre">AppKernel::registerContainerConfiguration()</span></tt>, el cual carga un archivo de configuración específico al entorno (por ejemplo, <tt class="docutils literal"><span class="pre">config_dev.yml</span></tt> para el entorno <tt class="docutils literal"><span class="pre">dev</span></tt> o <tt class="docutils literal"><span class="pre">config_prod.yml</span></tt> para <tt class="docutils literal"><span class="pre">prod</span></tt>).</p>
</div>
<p>Una instancia del objeto <tt class="docutils literal"><span class="pre">Acme\HolaBundle\Mailer</span></tt> ahora está disponible a través del contenedor de servicios. El contenedor está disponible en cualquier controlador tradicional de Symfony2, desde donde puedes acceder al servicio del contenedor a través del método <tt class="docutils literal"><span class="pre">get()</span></tt>:</p>
<div class="highlight-python"><pre>class HolaController extends Controller
{
    // ...

    public function sendEmailAction()
    {
        // ...
        $cartero = $this-&gt;get('mi_cartero');
        $cartero-&gt;send('ryan@foobar.net', ... );
    }
}</pre>
</div>
<p>Cuando pedimos el servicio <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> desde el contenedor, el contenedor construye el objeto y lo devuelve. Esta es otra de las principales ventajas de utilizar el contenedor de servicios. Es decir, un servicio <em>nunca</em> es construido hasta que es necesario. Si defines un servicio y no lo utilizas en una petición, el servicio no se crea. Esto ahorra memoria y aumenta la velocidad de tu aplicación.
Esto también significa que la sanción en rendimiento por definir muchos servicios es muy poca o ninguna. Los servicios que nunca se usan nunca se construyen.</p>
<p>Como bono adicional, el servicio <tt class="docutils literal"><span class="pre">Mailer</span></tt> se crea sólo una vez y se vuelve a utilizar la misma instancia cada vez que solicites el servicio. Este casi siempre es el comportamiento que tendrá (el cual es más flexible y potente), pero vamos a aprender más adelante cómo puedes configurar un servicio que tiene varias instancias.</p>
</div>
<div class="section" id="parametros-del-servicio">
<span id="book-service-container-parameters"></span><h2>Parámetros del servicio<a class="headerlink" href="#parametros-del-servicio" title="Permalink to this headline">¶</a></h2>
<p>La creación de nuevos servicios (es decir, objetos) a través del contenedor es bastante sencilla. Los parámetros provocan que al definir los servicios estén más organizados y sean más flexibles:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre># app/config/config.yml
parameters:
    mi_cartero.class:      Acme\HolaBundle\Mailer
    mi_cartero.transport:  sendmail

services:
    mi_cartero:
        class:        %my_mailer.class%
        arguments:    [%my_mailer.transport%]</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/config.xml --&gt;</span>
<span class="nt">&lt;parameters&gt;</span>
    <span class="nt">&lt;parameter</span> <span class="na">key=</span><span class="s">&quot;mi_cartero.class&quot;</span><span class="nt">&gt;</span>Acme\HolaBundle\Mailer<span class="nt">&lt;/parameter&gt;</span>
    <span class="nt">&lt;parameter</span> <span class="na">key=</span><span class="s">&quot;mi_cartero.transport&quot;</span><span class="nt">&gt;</span>sendmail<span class="nt">&lt;/parameter&gt;</span>
<span class="nt">&lt;/parameters&gt;</span>

<span class="nt">&lt;services&gt;</span>
    <span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;mi_cartero&quot;</span> <span class="na">class=</span><span class="s">&quot;%my_mailer.class%&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;argument&gt;</span>%my_mailer.transport%<span class="nt">&lt;/argument&gt;</span>
    <span class="nt">&lt;/service&gt;</span>
<span class="nt">&lt;/services&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// app/config/config.php</span>
<span class="x">use Symfony\Component\DependencyInjection\Definition;</span>

<span class="x">$contenedor-&gt;setParameter(&#39;mi_cartero.class&#39;, &#39;Acme\HolaBundle\Mailer&#39;);</span>
<span class="x">$contenedor-&gt;setParameter(&#39;mi_cartero.transport&#39;, &#39;sendmail&#39;);</span>

<span class="x">$contenedor-&gt;setDefinition(&#39;mi_cartero&#39;, new Definition(</span>
<span class="x">    &#39;%my_mailer.class%&#39;,</span>
<span class="x">    array(&#39;%my_mailer.transport%&#39;)</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>El resultado final es exactamente igual que antes - la diferencia es sólo en <em>cómo</em> definimos el servicio. Al rodear las cadenas <tt class="docutils literal"><span class="pre">mi_cartero.class</span></tt> y <tt class="docutils literal"><span class="pre">mi_cartero.transport</span></tt> entre signos de porcentaje (<tt class="docutils literal"><span class="pre">%</span></tt>), el contenedor sabe que tiene que buscar los parámetros con esos nombres. Cuando se construye el contenedor, este busca el valor de cada parámetro y lo utiliza en la definición del servicio.</p>
<p>El propósito de los parámetros es alimentar información a los servicios. Por supuesto no había nada malo en la definición del servicio sin utilizar ningún parámetro.
Los parámetros, sin embargo, tienen varias ventajas:</p>
<ul class="simple">
<li>Separan y organizan todo el servicio en &#8220;opciones&#8221; bajo un sola clave <tt class="docutils literal"><span class="pre">parameters</span></tt>;</li>
<li>Los valores del parámetro se pueden utilizar en la definición de múltiples servicios;</li>
<li>Cuando creas un servicio en un paquete (vamos a mostrar esto en breve), utilizar parámetros permite que el servicio sea fácil de personalizar en tu aplicación.</li>
</ul>
<p>La opción de usar o no parámetros depende de ti. Los paquetes de alta calidad de terceros <em>siempre</em> usan parámetros, ya que producen servicios almacenados en el contenedor más configurables. Para los servicios de tu aplicación, sin embargo, posiblemente no necesites la flexibilidad de los parámetros.</p>
</div>
<div class="section" id="importando-la-configuracion-de-recursos-desde-otros-contenedores">
<h2>Importando la configuración de recursos desde otros contenedores<a class="headerlink" href="#importando-la-configuracion-de-recursos-desde-otros-contenedores" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">En esta sección, nos referiremos a los archivos de configuración de servicios como <em>recursos</em>.
Se trata de resaltar el hecho de que, si bien la mayoría de la configuración de recursos debe estar en archivos (por ejemplo, YAML, XML, PHP), Symfony2 es tan flexible que la configuración se puede cargar desde cualquier lugar (por ejemplo, una base de datos e incluso a través de un servicio web externo).</p>
</div>
<p>El contenedor de servicios se construye usando un recurso de configuración simple (<tt class="docutils literal"><span class="pre">app/config/config.yml</span></tt> por omisión). Toda la configuración de otros servicios (incluido el núcleo de Symfony2 y la configuración de paquetes de terceros) se debe importar desde el interior de este archivo en una u otra forma. Esto proporciona absoluta flexibilidad sobre los servicios en tu aplicación.</p>
<p>La configuración externa de servicios se puede importar de dos maneras diferentes. En primer lugar, vamos a hablar sobre el método que utilizarás con más frecuencia en tu aplicación: la Directiva <tt class="docutils literal"><span class="pre">imports</span></tt>. En la siguiente sección, vamos a introducir el segundo método, que es el método flexible y preferido para importar la configuración del servicio desde paquetes de terceros.</p>
<div class="section" id="importando-configuracion-con-imports">
<span id="service-container-imports-directive"></span><span id="index-4"></span><h3>Importando configuración con <tt class="docutils literal"><span class="pre">imports</span></tt><a class="headerlink" href="#importando-configuracion-con-imports" title="Permalink to this headline">¶</a></h3>
<p>Hasta ahora, hemos puesto nuestra definición del contenedor del servicio <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> directamente en el archivo de configuración de la aplicación (por ejemplo, <tt class="docutils literal"><span class="pre">app/config/config.yml</span></tt>). Por supuesto, debido a que la clase <tt class="docutils literal"><span class="pre">Mailer</span></tt> vive dentro de <tt class="docutils literal"><span class="pre">AcmeHolaBundle</span></tt>, tiene más sentido poner la definición del contenedor de <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> en el paquete también.</p>
<p>En primer lugar, mueve la definición del contenedor de <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> a un nuevo archivo contenedor de recursos dentro <tt class="docutils literal"><span class="pre">AcmeHolaBundle</span></tt>. Si los directorios <tt class="docutils literal"><span class="pre">Resourses</span></tt> y <tt class="docutils literal"><span class="pre">Resourses/config</span></tt> no existen, créalos.</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre># src/Acme/HolaBundle/Resources/config/services.yml
parameters:
    mi_cartero.class:      Acme\HolaBundle\Mailer
    mi_cartero.transport:  sendmail

services:
    mi_cartero:
        class:        %my_mailer.class%
        arguments:    [%my_mailer.transport%]</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- src/Acme/HolaBundle/Resources/config/services.xml --&gt;</span>
<span class="nt">&lt;parameters&gt;</span>
    <span class="nt">&lt;parameter</span> <span class="na">key=</span><span class="s">&quot;mi_cartero.class&quot;</span><span class="nt">&gt;</span>Acme\HolaBundle\Mailer<span class="nt">&lt;/parameter&gt;</span>
    <span class="nt">&lt;parameter</span> <span class="na">key=</span><span class="s">&quot;mi_cartero.transport&quot;</span><span class="nt">&gt;</span>sendmail<span class="nt">&lt;/parameter&gt;</span>
<span class="nt">&lt;/parameters&gt;</span>

<span class="nt">&lt;services&gt;</span>
    <span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;mi_cartero&quot;</span> <span class="na">class=</span><span class="s">&quot;%my_mailer.class%&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;argument&gt;</span>%my_mailer.transport%<span class="nt">&lt;/argument&gt;</span>
    <span class="nt">&lt;/service&gt;</span>
<span class="nt">&lt;/services&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// src/Acme/HolaBundle/Resources/config/services.php</span>
<span class="x">use Symfony\Component\DependencyInjection\Definition;</span>

<span class="x">$contenedor-&gt;setParameter(&#39;mi_cartero.class&#39;, &#39;Acme\HolaBundle\Mailer&#39;);</span>
<span class="x">$contenedor-&gt;setParameter(&#39;mi_cartero.transport&#39;, &#39;sendmail&#39;);</span>

<span class="x">$contenedor-&gt;setDefinition(&#39;mi_cartero&#39;, new Definition(</span>
<span class="x">    &#39;%my_mailer.class%&#39;,</span>
<span class="x">    array(&#39;%my_mailer.transport%&#39;)</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>La propia definición no ha cambiado, sólo su ubicación. Por supuesto, el contenedor de servicios no sabe sobre el nuevo archivo de recursos. Afortunadamente, es fácil importar el archivo de recursos utilizando la clave <tt class="docutils literal"><span class="pre">imports</span></tt> en la configuración de la aplicación.</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre># app/config/config.yml
imports:
    hola_bundle:
        resource: @AcmeHolaBundle/Resources/config/services.yml</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/config.xml --&gt;</span>
<span class="nt">&lt;imports&gt;</span>
    <span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&quot;@AcmeHolaBundle/Resources/config/services.xml&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/imports&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// app/config/config.php</span>
<span class="x">$this-&gt;import(&#39;@AcmeHolaBundle/Resources/config/services.php&#39;);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>La directiva <tt class="docutils literal"><span class="pre">imports</span></tt> permite a tu aplicación incluir recursos de configuración del contenedor de servicios de cualquier otro lugar (comúnmente desde paquetes).
La ubicación de <tt class="docutils literal"><span class="pre">resourses</span></tt>, para archivos, es la ruta absoluta al archivo de recursos. La sintaxis especial <tt class="docutils literal"><span class="pre">&#64;AcmeHola</span></tt> resuelve la ruta al directorio del paquete <tt class="docutils literal"><span class="pre">AcmeHolaBundle</span></tt>. Esto te ayuda a especificar la ruta a los recursos sin tener que preocuparte más adelante de si se mueve el <tt class="docutils literal"><span class="pre">AcmeHolaBundle</span></tt> a un directorio diferente.</p>
</div>
<div class="section" id="importando-configuracion-via-extensiones-del-contenedor">
<span id="service-container-extension-configuration"></span><span id="index-5"></span><h3>Importando configuración vía extensiones del contenedor<a class="headerlink" href="#importando-configuracion-via-extensiones-del-contenedor" title="Permalink to this headline">¶</a></h3>
<p>Cuando desarrollas en Symfony2, comúnmente debes usar la directiva <tt class="docutils literal"><span class="pre">imports</span></tt> para importar la configuración del contenedor desde los paquetes que haz creado específicamente para tu aplicación. La configuración del paquete contenedor de terceros, incluyendo los servicios básicos de Symfony2, normalmente se cargan con cualquier otro método que sea más flexible y fácil de configurar en tu aplicación.</p>
<p>Así es como funciona. Internamente, cada paquete define sus servicios muy parecido a lo que hemos visto hasta ahora. Es decir, un paquete utiliza uno o más archivos de configuración de recursos (por lo general XML) para especificar los parámetros y servicios para ese paquete. Sin embargo, en lugar de importar cada uno de estos recursos directamente desde la configuración de tu aplicación utilizando la directiva <tt class="docutils literal"><span class="pre">imports</span></tt>, sólo tienes que invocar una <em>extensión contenedora de servicios</em> dentro del paquete, la cual hace el trabajo por ti. Una extensión del contenedor de servicios es una clase PHP creada por el autor del paquete para lograr dos cosas:</p>
<ul class="simple">
<li>Importar todos los recursos del contenedor de servicios necesarios para configurar los servicios del paquete;</li>
<li>permite una configuración semántica y directa para poder configurar el paquete sin interactuar con los parámetros de configuración planos del paquete contenedor del servicio.</li>
</ul>
<p>En otras palabras, una extensión del contenedor de servicios configura los servicios para un paquete en tu nombre. Y como veremos en un momento, la extensión proporciona una interfaz sensible y de alto nivel para configurar el paquete.</p>
<p>Tomemos el <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt> - el núcleo de la plataforma de Symfony2 - como ejemplo. La presencia del siguiente código en la configuración de tu aplicación invoca a la extensión en el interior del contenedor de servicios <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">framework</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">secret</span><span class="p-Indicator">:</span>          <span class="l-Scalar-Plain">xxxxxxxxxx</span>
    <span class="l-Scalar-Plain">charset</span><span class="p-Indicator">:</span>         <span class="l-Scalar-Plain">UTF-8</span>
    <span class="l-Scalar-Plain">form</span><span class="p-Indicator">:</span>            <span class="l-Scalar-Plain">true</span>
    <span class="l-Scalar-Plain">csrf_protection</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
    <span class="l-Scalar-Plain">router</span><span class="p-Indicator">:</span>        <span class="p-Indicator">{</span> <span class="nv">resource</span><span class="p-Indicator">:</span> <span class="s">&quot;%kernel.root_dir%/config/routing.yml&quot;</span> <span class="p-Indicator">}</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/config.xml --&gt;</span>
<span class="nt">&lt;framework:config</span> <span class="na">charset=</span><span class="s">&quot;UTF-8&quot;</span> <span class="na">secret=</span><span class="s">&quot;xxxxxxxxxx&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;framework:form</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;framework:csrf-protection</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;framework:router</span> <span class="na">resource=</span><span class="s">&quot;%kernel.root_dir%/config/routing.xml&quot;</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;/framework&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// app/config/config.php</span>
<span class="x">$contenedor-&gt;loadFromExtension(&#39;framework&#39;, array(</span>
<span class="x">    &#39;secret&#39;          =&gt; &#39;xxxxxxxxxx&#39;,</span>
<span class="x">    &#39;charset&#39;         =&gt; &#39;UTF-8&#39;,</span>
<span class="x">    &#39;form&#39;            =&gt; array(),</span>
<span class="x">    &#39;csrf-protection&#39; =&gt; array(),</span>
<span class="x">    &#39;router&#39;          =&gt; array(&#39;resource&#39; =&gt; &#39;%kernel.root_dir%/config/routing.php&#39;),</span>
<span class="x">    // ...</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Cuando se analiza la configuración, el contenedor busca una extensión que pueda manejar la directiva de configuración <tt class="docutils literal"><span class="pre">framework</span></tt>. La extensión en cuestión, que vive en el <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt>, es invocada y cargada la configuración del servicio para el <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt>. Si quitas la clave <tt class="docutils literal"><span class="pre">framework</span></tt> del archivo de configuración de tu aplicación por completo, no se cargarán los servicios básicos de Symfony2. El punto es que tú tienes el control: la plataforma Symfony2 no contiene ningún tipo de magia o realiza cualquier acción en que tú no tengas el control.</p>
<p>Por supuesto que puedes hacer mucho más que simplemente &#8220;activar&#8221; la extensión del contenedor de servicios del <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt>. Cada extensión te permite personalizar fácilmente el paquete, sin tener que preocuparte acerca de cómo se definen los servicios internos.</p>
<p>En este caso, la extensión te permite personalizar el juego de caracteres - <tt class="docutils literal"><span class="pre">charset</span></tt>, gestor de errores - <tt class="docutils literal"><span class="pre">error_handler</span></tt>, protección CSRF - <tt class="docutils literal"><span class="pre">csrf_protection</span></tt>, configuración del ruteador - <tt class="docutils literal"><span class="pre">router</span></tt> - y mucho más. Internamente, el <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt> utiliza las opciones especificadas aquí para definir y configurar los servicios específicos del mismo. El paquete se encarga de crear todos los <tt class="docutils literal"><span class="pre">parámetros</span></tt> y <tt class="docutils literal"><span class="pre">servicios</span></tt> necesarios para el contenedor de servicios, mientras permite que la mayor parte de la configuración se pueda personalizar fácilmente. Como bono adicional, la mayoría de las extensiones del contenedor de servicios también son lo suficientemente inteligentes como para realizar la validación - notificándote las opciones que faltan o el tipo de los datos incorrectos.</p>
<p>Al instalar o configurar un paquete, consulta la documentación del paquete de cómo se deben instalar y configurar los servicios para el paquete. Las opciones disponibles para los paquetes básicos se pueden encontrar dentro de la <a class="reference internal" href="../reference/index.html"><em>Guía de Referencia</em></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">De forma nativa, el contenedor de servicios sólo reconoce las directivas <tt class="docutils literal"><span class="pre">parameters</span></tt>, <tt class="docutils literal"><span class="pre">services</span></tt> e <tt class="docutils literal"><span class="pre">imports</span></tt>. Cualquier otra directiva es manejada por una extensión del contenedor de servicios.</p>
</div>
</div>
</div>
<div class="section" id="refiriendo-inyectando-servicios">
<span id="index-6"></span><h2>Refiriendo (inyectando) servicios<a class="headerlink" href="#refiriendo-inyectando-servicios" title="Permalink to this headline">¶</a></h2>
<p>Hasta el momento, nuestro servicio original <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> es simple: sólo toma un argumento en su constructor, el cual es fácilmente configurable. Como verás, el poder real del contenedor se realiza cuando es necesario crear un servicio que depende de uno o varios otros servicios en el contenedor.</p>
<p>Comencemos con un ejemplo. Supongamos que tenemos un nuevo servicio, <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt>, que ayuda a gestionar la preparación y entrega de un mensaje de correo electrónico a una colección de direcciones. Por supuesto el servicio <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> ya es realmente bueno en la entrega de mensajes de correo electrónico, así que lo usaremos dentro de <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt> para manejar la entrega real de los mensajes. Se pretende que esta clase pudiera ser algo como esto:</p>
<div class="highlight-python"><pre>namespace Acme\HolaBundle\Newsletter;

use Acme\HolaBundle\Mailer;

class NewsletterManager
{
    protected $cartero;

    public function __construct(Mailer $cartero)
    {
        $this-&gt;mailer = $cartero;
    }

    // ...
}</pre>
</div>
<p>Sin utilizar el contenedor de servicios, podemos crear un nuevo <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt> muy fácilmente desde el interior de un controlador:</p>
<div class="highlight-python"><pre>public function sendNewsletterAction()
{
    $cartero = $this-&gt;get('mi_cartero');
    $newsletter = new Acme\HolaBundle\Newsletter\NewsletterManager($cartero);
    // ...
}</pre>
</div>
<p>Este enfoque está bien, pero, ¿si más adelante decidimos que la clase <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt> necesita un segundo o tercer argumento constructor? ¿Y si nos decidimos a reconstruir nuestro código y cambiar el nombre de la clase? En ambos casos, habría que encontrar todos los lugares donde se crea una instancia de <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt> y modificarla. Por supuesto, el contenedor de servicios nos da una opción mucho más atractiva:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre># src/Acme/HolaBundle/Resources/config/services.yml
parameters:
    # ...
    newsletter_manager.class: Acme\HolaBundle\Newsletter\NewsletterManager

services:
    mi_cartero:
        # ...
    newsletter_manager:
        class:     %newsletter_manager.class%
        arguments: [@mi_cartero]</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><pre>&lt;!-- src/Acme/HolaBundle/Resources/config/services.xml --&gt;
&lt;parameters&gt;
    &lt;!-- ... --&gt;
    &lt;parameter key="newsletter_manager.class"&gt;Acme\HolaBundle\Newsletter\NewsletterManager&lt;/parameter&gt;
&lt;/parameters&gt;

&lt;services&gt;
    &lt;service id="mi_cartero" ... &gt;
      &lt;!-- ... --&gt;
    &lt;/service&gt;
    &lt;service id="newsletter_manager" class="%newsletter_manager.class%"&gt;
        &lt;argument type="service" id="mi_cartero"/&gt;
    &lt;/service&gt;
&lt;/services&gt;</pre>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// src/Acme/HolaBundle/Resources/config/services.php</span>
<span class="x">use Symfony\Component\DependencyInjection\Definition;</span>
<span class="x">use Symfony\Component\DependencyInjection\Reference;</span>

<span class="x">// ...</span>
<span class="x">$contenedor-&gt;setParameter(&#39;newsletter_manager.class&#39;, &#39;Acme\HolaBundle\Newsletter\NewsletterManager&#39;);</span>

<span class="x">$contenedor-&gt;setDefinition(&#39;mi_cartero&#39;, ... );</span>
<span class="x">$contenedor-&gt;setDefinition(&#39;newsletter_manager&#39;, new Definition(</span>
<span class="x">    &#39;%newsletter_manager.class%&#39;,</span>
<span class="x">    array(new Reference(&#39;mi_cartero&#39;))</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>En YAML, la sintaxis especial <tt class="docutils literal"><span class="pre">&#64;mi_cartero</span></tt> le dice al contenedor que busque un servicio llamado <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> y pase ese objeto al constructor de <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt>. En este caso, sin embargo, el servicio especificado <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> debe existir. Si no es así, lanzará una excepción. Puedes marcar tus dependencias como opcionales - explicaremos esto en la siguiente sección.</p>
<p>La utilización de referencias es una herramienta muy poderosa que te permite crear clases de servicios independientes con dependencias bien definidas. En este ejemplo, el servicio <tt class="docutils literal"><span class="pre">newsletter_manager</span></tt> necesita del servicio <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> para poder funcionar. Al definir esta dependencia en el contenedor de servicios, el contenedor se encarga de todo el trabajo de crear instancias de objetos.</p>
<div class="section" id="dependencias-opcionales-inyeccion-de-definidores">
<h3>Dependencias opcionales: Inyección de definidores<a class="headerlink" href="#dependencias-opcionales-inyeccion-de-definidores" title="Permalink to this headline">¶</a></h3>
<p>Inyectar dependencias en el constructor de esta manera es una excelente manera de asegurarte que la dependencia está disponible para usarla. Si tienes dependencias opcionales para una clase, entonces, la &#8220;inyección de definidor&#8221; puede ser una mejor opción. Esto significa inyectar la dependencia usando una llamada a método en lugar de a través del constructor. La clase se vería así:</p>
<div class="highlight-python"><pre>namespace Acme\HolaBundle\Newsletter;

use Acme\HolaBundle\Mailer;

class NewsletterManager
{
    protected $cartero;

    public function setMailer(Mailer $cartero)
    {
        $this-&gt;mailer = $cartero;
    }

    // ...
}</pre>
</div>
<p>La inyección de la dependencia por medio del método definidor sólo necesita un cambio de sintaxis:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre># src/Acme/HolaBundle/Resources/config/services.yml
parameters:
    # ...
    newsletter_manager.class: Acme\HolaBundle\Newsletter\NewsletterManager

services:
    mi_cartero:
        # ...
    newsletter_manager:
        class:     %newsletter_manager.class%
        calls:
            - [ setMailer, [ @mi_cartero ] ]</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><pre>&lt;!-- src/Acme/HolaBundle/Resources/config/services.xml --&gt;
&lt;parameters&gt;
    &lt;!-- ... --&gt;
    &lt;parameter key="newsletter_manager.class"&gt;Acme\HolaBundle\Newsletter\NewsletterManager&lt;/parameter&gt;
&lt;/parameters&gt;

&lt;services&gt;
    &lt;service id="mi_cartero" ... &gt;
      &lt;!-- ... --&gt;
    &lt;/service&gt;
    &lt;service id="newsletter_manager" class="%newsletter_manager.class%"&gt;
        &lt;call method="setMailer"&gt;
             &lt;argument type="service" id="mi_cartero" /&gt;
        &lt;/call&gt;
    &lt;/service&gt;
&lt;/services&gt;</pre>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// src/Acme/HolaBundle/Resources/config/services.php</span>
<span class="x">use Symfony\Component\DependencyInjection\Definition;</span>
<span class="x">use Symfony\Component\DependencyInjection\Reference;</span>

<span class="x">// ...</span>
<span class="x">$contenedor-&gt;setParameter(&#39;newsletter_manager.class&#39;, &#39;Acme\HolaBundle\Newsletter\NewsletterManager&#39;);</span>

<span class="x">$contenedor-&gt;setDefinition(&#39;mi_cartero&#39;, ... );</span>
<span class="x">$contenedor-&gt;setDefinition(&#39;newsletter_manager&#39;, new Definition(</span>
<span class="x">    &#39;%newsletter_manager.class%&#39;</span>
<span class="x">))-&gt;addMethodCall(&#39;setMailer&#39;, array(</span>
<span class="x">    new Reference(&#39;mi_cartero&#39;)</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Los enfoques presentados en esta sección se llaman &#8220;inyección de constructor&#8221; e &#8220;inyección de definidor&#8221;. El contenedor de servicios de Symfony2 también es compatible con la &#8220;inyección de propiedad&#8221;.</p>
</div>
</div>
</div>
<div class="section" id="haciendo-referencias-opcionales">
<h2>Haciendo referencias opcionales<a class="headerlink" href="#haciendo-referencias-opcionales" title="Permalink to this headline">¶</a></h2>
<p>A veces, uno de tus servicios puede tener una dependencia opcional, lo cual significa que la dependencia no es necesaria para que el servicio funcione correctamente. En el ejemplo anterior, el servicio <tt class="docutils literal"><span class="pre">mi_cartero</span></tt> <em>debe</em> existir, si no, será lanzada una excepción. Al modificar la definición del servicio <tt class="docutils literal"><span class="pre">newsletter_manager</span></tt>, puedes hacer opcional esta referencia. Entonces, el contenedor será inyectado si es que existe y no hace nada si no:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre># src/Acme/HolaBundle/Resources/config/services.yml
parameters:
    # ...

services:
    newsletter_manager:
        class:     %newsletter_manager.class%
        arguments: [@?mi_cartero]</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><pre>&lt;!-- src/Acme/HolaBundle/Resources/config/services.xml --&gt;

&lt;services&gt;
    &lt;service id="mi_cartero" ... &gt;
      &lt;!-- ... --&gt;
    &lt;/service&gt;
    &lt;service id="newsletter_manager" class="%newsletter_manager.class%"&gt;
        &lt;argument type="service" id="mi_cartero" on-invalid="ignore" /&gt;
    &lt;/service&gt;
&lt;/services&gt;</pre>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">// src/Acme/HolaBundle/Resources/config/services.php</span>
<span class="x">use Symfony\Component\DependencyInjection\Definition;</span>
<span class="x">use Symfony\Component\DependencyInjection\Reference;</span>
<span class="x">use Symfony\Component\DependencyInjection\ContainerInterface;</span>

<span class="x">// ...</span>
<span class="x">$contenedor-&gt;setParameter(&#39;newsletter_manager.class&#39;, &#39;Acme\HolaBundle\Newsletter\NewsletterManager&#39;);</span>

<span class="x">$contenedor-&gt;setDefinition(&#39;mi_cartero&#39;, ... );</span>
<span class="x">$contenedor-&gt;setDefinition(&#39;newsletter_manager&#39;, new Definition(</span>
<span class="x">    &#39;%newsletter_manager.class%&#39;,</span>
<span class="x">    array(new Reference(&#39;mi_cartero&#39;, ContainerInterface::IGNORE_ON_INVALID_REFERENCE))</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>En YAML, la sintaxis especial <tt class="docutils literal"><span class="pre">&#64;?</span></tt> le dice al contenedor de servicios que la dependencia es opcional. Por supuesto, <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt> también se debe escribir para permitir una dependencia opcional:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">public function __construct(Mailer $cartero = null)</span>
<span class="x">{</span>
<span class="x">    // ...</span>
<span class="x">}</span>
</pre></div>
</div>
</div>
<div class="section" id="el-nucleo-de-symfony-y-servicios-en-un-paquete-de-terceros">
<h2>El núcleo de Symfony y servicios en un paquete de terceros<a class="headerlink" href="#el-nucleo-de-symfony-y-servicios-en-un-paquete-de-terceros" title="Permalink to this headline">¶</a></h2>
<p>Puesto que Symfony2 y todos los paquetes de terceros configuran y recuperan sus servicios a través del contenedor, puedes acceder fácilmente a ellos e incluso utilizarlos en tus propios servicios. Para mantener las cosas simples, de manera predeterminada Symfony2 no requiere que los controladores se definan como servicios. Además Symfony2 inyecta el contenedor de servicios completo en el controlador. Por ejemplo, para manejar el almacenamiento de información sobre la sesión de un usuario, Symfony2 proporciona un servicio <tt class="docutils literal"><span class="pre">sesión</span></tt>, al cual se puede acceder dentro de un controlador estándar de la siguiente manera:</p>
<div class="highlight-python"><pre>public function indexAction($bar)
{
    $sesion = $this-&gt;get('sesion');
    $sesion-&gt;set('foo', $bar);

    // ...
}</pre>
</div>
<p>En Symfony2, constantemente vas a utilizar los servicios prestados por el núcleo de Symfony o paquetes de terceros para realizar tareas como la reproducción de plantillas (<tt class="docutils literal"><span class="pre">templating</span></tt>), el envío de mensajes de correo electrónico (<tt class="docutils literal"><span class="pre">mailer</span></tt>), o para acceder a información sobre la petición.</p>
<p>Podemos dar un paso más allá usando estos servicios dentro de los servicios que haz creado para tu aplicación. Vamos a modificar el <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt> para usar el gestor de correo real de Symfony2, el servicio <tt class="docutils literal"><span class="pre">mailer</span></tt> (en vez del pretendido <tt class="docutils literal"><span class="pre">mi_cartero</span></tt>).
También vamos a pasar el servicio del motor de plantillas al <tt class="docutils literal"><span class="pre">NewsletterManager</span></tt> para que puedas generar el contenido del correo electrónico a través de una plantilla:</p>
<div class="highlight-python"><pre>namespace Acme\HolaBundle\Newsletter;

use Symfony\Component\Templating\EngineInterface;

class NewsletterManager
{
    protected $cartero;

    protected $plantilla;

    public function __construct(\Swift_Mailer $cartero, EngineInterface $plantilla)
    {
        $this-&gt;mailer = $cartero;
        $this-&gt;templating = $plantilla;
    }

    // ...
}</pre>
</div>
<p>Configurar el contenedor de servicios es fácil:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre>services:
    newsletter_manager:
        class:     %newsletter_manager.class%
        arguments: [@mailer, @templating]</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;newsletter_manager&quot;</span> <span class="na">class=</span><span class="s">&quot;%newsletter_manager.class%&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;argument</span> <span class="na">type=</span><span class="s">&quot;service&quot;</span> <span class="na">id=</span><span class="s">&quot;mailer&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;argument</span> <span class="na">type=</span><span class="s">&quot;service&quot;</span> <span class="na">id=</span><span class="s">&quot;templating&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/service&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">$contenedor-&gt;setDefinition(&#39;newsletter_manager&#39;, new Definition(</span>
<span class="x">    &#39;%newsletter_manager.class%&#39;,</span>
<span class="x">    array(</span>
<span class="x">        new Reference(&#39;mailer&#39;),</span>
<span class="x">        new Reference(&#39;templating&#39;)</span>
<span class="x">    )</span>
<span class="x">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>El servicio <tt class="docutils literal"><span class="pre">newsletter_manager</span></tt> ahora tiene acceso a los servicios del núcleo <tt class="docutils literal"><span class="pre">mailer</span></tt> y <tt class="docutils literal"><span class="pre">templating</span></tt>. Esta es una forma común de crear servicios específicos para tu aplicación que aprovechan el poder de los distintos servicios en la plataforma.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Asegúrate de que la entrada <tt class="docutils literal"><span class="pre">SwiftMailer</span></tt> aparece en la configuración de la aplicación. Como mencionamos en <a class="reference internal" href="#service-container-extension-configuration"><em>Importando configuración vía extensiones del contenedor</em></a>, la clave <tt class="docutils literal"><span class="pre">SwiftMailer</span></tt> invoca a la extensión de servicio desde <tt class="docutils literal"><span class="pre">SwiftmailerBundle</span></tt>, la cual registra el servicio <tt class="docutils literal"><span class="pre">mailer</span></tt>.</p>
</div>
</div>
<div class="section" id="configuracion-avanzada-del-contenedor">
<span id="index-7"></span><h2>Configuración avanzada del contenedor<a class="headerlink" href="#configuracion-avanzada-del-contenedor" title="Permalink to this headline">¶</a></h2>
<p>Como hemos visto, definir servicios dentro del contenedor es fácil, generalmente implica una clave de configuración <tt class="docutils literal"><span class="pre">service</span></tt> y algunos parámetros. Sin embargo, el contenedor tiene varias otras herramientas disponibles que ayudan a <em>etiquetar</em> servicios por funcionalidad especial, crear servicios más complejos y realizar operaciones después de que el contenedor está construido.</p>
<div class="section" id="marcando-servicios-como-publico-privado">
<h3>Marcando servicios como público / privado<a class="headerlink" href="#marcando-servicios-como-publico-privado" title="Permalink to this headline">¶</a></h3>
<p>Cuando definas servicios, generalmente, querrás poder acceder a estas definiciones dentro del código de tu aplicación. Estos servicios se llaman <tt class="docutils literal"><span class="pre">public</span></tt>. Por ejemplo, el servicio <tt class="docutils literal"><span class="pre">doctrine</span></tt> registrado en el contenedor cuando se utiliza <tt class="docutils literal"><span class="pre">DoctrineBundle</span></tt> es un servicio público al que puedes acceder a través de:</p>
<div class="highlight-python"><pre>$doctrine = $contenedor-&gt;get('doctrine');</pre>
</div>
<p>Sin embargo, hay casos de uso cuando no quieres que un servicio sea público. Esto es común cuando sólo se define un servicio, ya que se podría utilizar como argumento para otro servicio.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Si utilizas un servicio privado como argumento a más de otro servicio, esto se traducirá en dos diferentes instancias utilizadas como la creación del servicio privado realizada en línea (por ejemplo, <tt class="docutils literal"><span class="pre">new</span> <span class="pre">PrivateFooBar()</span></tt>).</p>
</div>
<p>Dice simplemente: El servicio será privado cuando no deseas acceder a él directamente desde tu código.</p>
<p>Aquí está un ejemplo:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">services</span><span class="p-Indicator">:</span>
   <span class="l-Scalar-Plain">foo</span><span class="p-Indicator">:</span>
     <span class="l-Scalar-Plain">class</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Acme\HolaBundle\Foo</span>
     <span class="l-Scalar-Plain">public</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">false</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;foo&quot;</span> <span class="na">class=</span><span class="s">&quot;Acme\HolaBundle\Foo&quot;</span> <span class="na">public=</span><span class="s">&quot;false&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">$definition = new Definition(&#39;Acme\HolaBundle\Foo&#39;);</span>
<span class="x">$definition-&gt;setPublic(false);</span>
<span class="x">$contenedor-&gt;setDefinition(&#39;foo&#39;, $definition);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Ahora que el servicio es privado, <em>no</em> puedes llamar a:</p>
<div class="highlight-python"><pre>$contenedor-&gt;get('foo');</pre>
</div>
<p>Sin embargo, si haz marcado un servicio como privado, todavía puedes asignarle un alias (ve más abajo) para acceder a este servicio (a través del alias).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Los servicios por omisión son públicos.</p>
</div>
</div>
<div class="section" id="rebautizando">
<h3>Rebautizando<a class="headerlink" href="#rebautizando" title="Permalink to this headline">¶</a></h3>
<p>Cuando utilizas el núcleo o paquetes de terceros dentro de tu aplicación, posiblemente desees utilizar métodos abreviados para acceder a algunos servicios. Puedes hacerlo rebautizándolos y, además, puedes incluso rebautizar servicios no públicos.</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">services</span><span class="p-Indicator">:</span>
   <span class="l-Scalar-Plain">foo</span><span class="p-Indicator">:</span>
     <span class="l-Scalar-Plain">class</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Acme\HolaBundle\Foo</span>
   <span class="l-Scalar-Plain">bar</span><span class="p-Indicator">:</span>
     <span class="l-Scalar-Plain">alias</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">foo</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;foo&quot;</span> <span class="na">class=</span><span class="s">&quot;Acme\HolaBundle\Foo&quot;</span><span class="nt">/&gt;</span>

<span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;bar&quot;</span> <span class="na">alias=</span><span class="s">&quot;foo&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">$definition = new Definition(&#39;Acme\HolaBundle\Foo&#39;);</span>
<span class="x">$contenedor-&gt;setDefinition(&#39;foo&#39;, $definition);</span>

<span class="x">$containerBuilder-&gt;setAlias(&#39;bar&#39;, &#39;foo&#39;);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Esto significa que cuando utilizas el contenedor directamente, puedes acceder al servicio <tt class="docutils literal"><span class="pre">foo</span></tt> al pedir el servicio <tt class="docutils literal"><span class="pre">bar</span></tt> así:</p>
<div class="highlight-python"><pre>$contenedor-&gt;get('bar'); // podrías devolver el servicio foo</pre>
</div>
</div>
<div class="section" id="incluyendo-archivos">
<h3>Incluyendo archivos<a class="headerlink" href="#incluyendo-archivos" title="Permalink to this headline">¶</a></h3>
<p>Puede haber casos de uso cuando necesites incluir otro archivo justo antes de cargar el servicio en sí. Para ello, puedes utilizar la directiva <tt class="docutils literal"><span class="pre">file</span></tt>.</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><pre>services:
   foo:
     class: Acme\HolaBundle\Foo\Bar
     file: %kernel.root_dir%/src/ruta/al/archivo/foo.php</pre>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;foo&quot;</span> <span class="na">class=</span><span class="s">&quot;Acme\HolaBundle\Foo\Bar&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;file&gt;</span>%kernel.root_dir%/src/rita/al/archivo/foo.php<span class="nt">&lt;/file&gt;</span>
<span class="nt">&lt;/service&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">$definition = new Definition(&#39;Acme\HolaBundle\Foo\Bar&#39;);</span>
<span class="x">$definition-&gt;setFile(&#39;%kernel.root_dir%/src/ruta/al/archivo/foo.php&#39;);</span>
<span class="x">$contenedor-&gt;setDefinition(&#39;foo&#39;, $definition);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Ten en cuenta que internamente Symfony llama a la función PHP require_once, lo cual significa que el archivo se incluirá una sola vez por petición.</p>
</div>
<div class="section" id="etiquetas-tags">
<span id="book-service-container-tags"></span><h3>Etiquetas (<tt class="docutils literal"><span class="pre">tags</span></tt>)<a class="headerlink" href="#etiquetas-tags" title="Permalink to this headline">¶</a></h3>
<p>De la misma manera que en la Web una entrada de blog se puede etiquetar con cosas tales como &#8220;Symfony&#8221; o &#8220;PHP&#8221;, los servicios configurados en el contenedor también se pueden etiquetar. En el contenedor de servicios, una etiqueta implica que el servicio está destinado a usarse para un propósito específico. Tomemos el siguiente ejemplo:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">services</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">foo.twig.extension</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">class</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Acme\HolaBundle\Extension\FooExtension</span>
        <span class="l-Scalar-Plain">tags</span><span class="p-Indicator">:</span>
            <span class="p-Indicator">-</span>  <span class="p-Indicator">{</span> <span class="nv">name</span><span class="p-Indicator">:</span> <span class="nv">twig.extension</span> <span class="p-Indicator">}</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;foo.twig.extension&quot;</span> <span class="na">class=</span><span class="s">&quot;Acme\HolaBundle\Extension\FooExtension&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;tag</span> <span class="na">name=</span><span class="s">&quot;twig.extension&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/service&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="x">$definition = new Definition(&#39;Acme\HolaBundle\Extension\FooExtension&#39;);</span>
<span class="x">$definition-&gt;addTag(&#39;twig.extension&#39;);</span>
<span class="x">$contenedor-&gt;setDefinition(&#39;foo.twig.extension&#39;, $definition);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>La etiqueta <tt class="docutils literal"><span class="pre">twig.extension</span></tt> es una etiqueta especial que <tt class="docutils literal"><span class="pre">TwigBundle</span></tt> usa
durante la configuración. Al dar al servicio esta etiqueta <tt class="docutils literal"><span class="pre">twig.extension</span></tt>, el paquete sabe que el servicio <tt class="docutils literal"><span class="pre">foo.twig.extension</span></tt> se debe registrar como una extensión Twig con Twig. En otras palabras, Twig encuentra todos los servicios con la etiqueta <tt class="docutils literal"><span class="pre">twig.extension</span></tt> y automáticamente los registra como extensiones.</p>
<p>Las etiquetas, entonces, son una manera de decirle a Symfony2 u otros paquetes de terceros que tu servicio se debe registrar o utilizar de alguna forma especial por el paquete.</p>
<p>La siguiente es una lista de etiquetas disponibles con los paquetes del núcleo de Symfony2.
Cada una de ellas tiene un efecto diferente en tu servicio y muchas etiquetas requieren argumentos adicionales (más allá de sólo el parámetro <tt class="docutils literal"><span class="pre">nombre</span></tt>).</p>
<ul class="simple">
<li>assetic.filter</li>
<li>assetic.templating.php</li>
<li>data_collector</li>
<li>form.field_factory.guesser</li>
<li>kernel.cache_warmer</li>
<li>kernel.event_listener</li>
<li>monolog.logger</li>
<li>routing.loader</li>
<li>security.listener.factory</li>
<li>security.voter</li>
<li>templating.helper</li>
<li>twig.extension</li>
<li>translation.loader</li>
<li>validator.constraint_validator</li>
</ul>
</div>
</div>
<div class="section" id="aprende-mas-en-el-recetario">
<h2>Aprende más en el recetario<a class="headerlink" href="#aprende-mas-en-el-recetario" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="../cookbook/service_container/factories.html"><em>Cómo utilizar el patrón fábrica para crear servicios</em></a></li>
<li><a class="reference internal" href="../cookbook/service_container/parentservices.html"><em>Cómo gestionar dependencias comunes con servicios padre</em></a></li>
<li><a class="reference internal" href="../cookbook/controller/service.html"><em>Cómo definir controladores como servicios</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Contenedor de servicios</a><ul>
<li><a class="reference internal" href="#que-es-un-servicio">¿Qué es un servicio?</a></li>
<li><a class="reference internal" href="#que-es-un-contenedor-de-servicios">¿Qué es un contenedor de servicios?</a></li>
<li><a class="reference internal" href="#creando-configurando-servicios-en-el-contenedor">Creando/configurando servicios en el contenedor</a></li>
<li><a class="reference internal" href="#parametros-del-servicio">Parámetros del servicio</a></li>
<li><a class="reference internal" href="#importando-la-configuracion-de-recursos-desde-otros-contenedores">Importando la configuración de recursos desde otros contenedores</a><ul>
<li><a class="reference internal" href="#importando-configuracion-con-imports">Importando configuración con <tt class="docutils literal"><span class="pre">imports</span></tt></a></li>
<li><a class="reference internal" href="#importando-configuracion-via-extensiones-del-contenedor">Importando configuración vía extensiones del contenedor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#refiriendo-inyectando-servicios">Refiriendo (inyectando) servicios</a><ul>
<li><a class="reference internal" href="#dependencias-opcionales-inyeccion-de-definidores">Dependencias opcionales: Inyección de definidores</a></li>
</ul>
</li>
<li><a class="reference internal" href="#haciendo-referencias-opcionales">Haciendo referencias opcionales</a></li>
<li><a class="reference internal" href="#el-nucleo-de-symfony-y-servicios-en-un-paquete-de-terceros">El núcleo de Symfony y servicios en un paquete de terceros</a></li>
<li><a class="reference internal" href="#configuracion-avanzada-del-contenedor">Configuración avanzada del contenedor</a><ul>
<li><a class="reference internal" href="#marcando-servicios-como-publico-privado">Marcando servicios como público / privado</a></li>
<li><a class="reference internal" href="#rebautizando">Rebautizando</a></li>
<li><a class="reference internal" href="#incluyendo-archivos">Incluyendo archivos</a></li>
<li><a class="reference internal" href="#etiquetas-tags">Etiquetas (<tt class="docutils literal"><span class="pre">tags</span></tt>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#aprende-mas-en-el-recetario">Aprende más en el recetario</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="translation.html"
                        title="previous chapter">Traduciendo</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="performance.html"
                        title="next chapter">Rendimiento</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/book/service_container.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="performance.html" title="Rendimiento"
             >next</a> |</li>
        <li class="right" >
          <a href="translation.html" title="Traduciendo"
             >previous</a> |</li>
        <li><a href="../index.html">symfony-docs-es v1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Libro</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Osukaru.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>